#!/bin/sh
# TazLito - SliTaz Live Tool.
#
# Tazlito is a tool to help generate and configure SliTaz LiveCD
# ISO images. You can create a custom distro in one command from a list of
# packages, extract an existing ISO image to hack it, create a new initramfs
# and/or a new ISO. Most commands must be run by root, except the stats
# and the configuration file manipulation.
#
# (C) 2007-2009 SliTaz - GNU General Public License.
#
# Authors : Christophe Lincoln <pankso@slitaz.org>
#           Pascal Bellard <pascal.bellard@slitaz.org>
#
VERSION=2.0

# Tazlito configuration variables to be shorter
# and to use words rather than numbers.
COMMAND=$1
LIST_NAME=$2
TMP_DIR=/tmp/tazlito-$$-$RANDOM
TMP_MNT=/media/tazlito-$$-$RANDOM
TOP_DIR=`pwd`
INITRAMFS=rootfs.gz
LOCALSTATE=/var/lib/tazpkg
INSTALLED=$LOCALSTATE/installed
CACHE_DIR=/var/cache/tazpkg
MIRROR=$LOCALSTATE/mirror
DEFAULT_MIRROR="http://mirror.slitaz.org/packages/`cat /etc/slitaz-release`/"

# Try to include config file, continue if command is gen-config or exit.
# The main config used by default is in /etc/tazlito.
if [ -f "/etc/tazlito/tazlito.conf" ] ; then
	CONFIG_FILE="/etc/tazlito/tazlito.conf"
fi
# Specific distro config file can be put in a distro tree.
if [ -f "$TOP_DIR/tazlito.conf" ] ; then
	CONFIG_FILE="$TOP_DIR/tazlito.conf"
fi
if [ ! "$CONFIG_FILE" = "" ] ; then
	. $CONFIG_FILE
else
	if [ "$COMMAND" = "gen-config" ] ; then
		continue
	else
		echo "Unable to find any configuration file. Please read the doc"
		echo "or run '`basename $0` gen-config' to get an empty config file."
		exit 0
	fi
fi

# While Tazpkg is not used the default mirror url file does not exist
# and user can't recharge the list of flavors.
if test $(id -u) = 0 ; then
	if [ ! -f "$MIRROR" ]; then
		echo "$DEFAULT_MIRROR" > $MIRROR
	fi
fi

# Set the rootfs and rootcd path with $DISTRO
# configuration variable.
ROOTFS=$DISTRO/rootfs
ROOTCD=$DISTRO/rootcd
FLAVORS_REPOSITORY=/home/slitaz/flavors

#####################
# Tazlito functions #
#####################

# Print the usage.
usage ()
{
	echo -e "\nSliTaz Live Tool - Version: $VERSION\n
\033[1mUsage: \033[0m `basename $0` [command] [list|iso|flavor] [dir]
\033[1mCommands: \033[0m\n
  usage           Print this short usage.
  stats           View Tazlito and distro configuration statistics.
  gen-config      Generate a new configuration file for a distro.
  configure       Configure the main config file or a specific tazlito.conf.
  gen-iso         Generate a new ISO from a distro tree.
  gen-initiso     Generate a new initramfs and ISO from the distro tree.
  list-flavors    List all available package lists on the mirror.
  gen-flavor      Generate a new live-CD description.
  gen-liveflavor  Generate a live-CD description from current system.
  show-flavor     Show live-CD description.
  get-flavor      Get a flavor's list of packages.
  upgrade-flavor  Update package list to the latest available versions.
  extract-flavor  Extract a (*.flavor) flavor into $FLAVORS_REPOSITORY.
  pack-flavor     Pack (and update) a flavor from $FLAVORS_REPOSITORY.
  check-list      Check a distro-packages.list for updates.
  extract-distro  Extract an ISO to a directory and rebuild LiveCD tree.
  gen-distro      Generate a Live distro and ISO from a list of packages.
  clean-distro    Remove all files generated by gen-distro.
  check-distro    Help to check if distro is ready to release.
  merge           Merge multiple rootfs into one iso.
  repack          Recompress rootfs into iso with maximum ratio.
  burn-iso        Burn ISO image to a cdrom using Wodim.\n"
}

# Status function.
status()
{
	local CHECK=$?
	echo -en "\\033[70G[ "
	if [ $CHECK = 0 ]; then
		echo -en "\\033[1;33mOK"
	else
		echo -en "\\033[1;31mFailed"
	fi
	echo -e "\\033[0;39m ]"
	return $CHECK
}

yesorno()
{
	echo -n "$1"
	case "$DEFAULT_ANSWER" in
	Y|y) answer="y";;
	N|n) answer="n";;
	*) read answer;;
	esac
}

field()
{
	grep "^$1" "$2" | sed 's/.*: \([0-9KMG\.]*\).*/\1/'
}

todomsg()
{
	echo -e "\\033[70G[ \\033[1;31mTODO\\033[0;39m ]"
}

# Download a file from this mirror
download_from()
{
	local i
	local mirrors
	mirrors="$1"
	shift
	for i in $mirrors; do
		case "$i" in
		http://*|ftp://*) wget -c $i$@ && break;;
		*) cp $i/$1 . && break;;
		esac
	done
}

# Download a file trying all mirrors
download()
{
	local i
	for i in $(cat $MIRROR $LOCALSTATE/undigest/*/mirror 2> /dev/null); do
		download_from "$i" "$@" && break
	done
}

# Execute hooks provided by some packages
genisohooks()
{
	local here=`pwd`
	cd $ROOTFS
	for i in $(ls etc/tazlito/*.$1 2> /dev/null); do
		. $i $ROOTCD
	done
	cd $here
}

cleanup()
{
	if [ -d $TMP_MNT ]; then
		umount $TMP_MNT
		rmdir $TMP_MNT
		rm -f /boot
	fi
}

# Echo the package name if the tazpkg is already installed
installed_package_name()
{
	local tazpkg
	local package
	local VERSION
	local EXTRAVERSION
	tazpkg=$1
	# Try to find package name and version to be able
	# to repack it from installation
	# A dash (-) can exist in name *and* in version
	package=${tazpkg%-*}
	i=$package
	while true; do
		VERSION=""
		eval $(grep -s ^VERSION= $INSTALLED/$i/receipt)
		EXTRAVERSION=""
		eval $(grep -s ^EXTRAVERSION= $INSTALLED/$i/receipt)
		if [ "$i-$VERSION$EXTRAVERSION" = "$tazpkg" ]; then
			echo $i
			break
		fi
		case "$i" in
		*-*);;
		*) break;;
		esac
		i=${i%-*}
	done
}

# Check if user is root.
check_root()
{
	if test $(id -u) != 0 ; then
	   echo -e "\nYou must be root to run `basename $0` with this option."
	   echo -e "Please type 'su' and root password to become super-user.\n"
	   exit 0
	fi
}

# Check for the rootfs tree.
check_rootfs()
{
	if [ ! -d "$ROOTFS/etc" ] ; then
		echo -e "\nUnable to find a distro rootfs...\n"
		exit 0
	fi
}

# Check for the boot dir into the root CD tree.
verify_rootcd()
{
	if [ ! -d "$ROOTCD/boot" ] ; then
		echo -e "\nUnable to find the rootcd boot directory...\n"
		exit 0
	fi
}

create_iso()
{
	genisoimage -R -o $1 -b boot/isolinux/isolinux.bin \
 		-c boot/isolinux/boot.cat -no-emul-boot -boot-load-size 4 \
		-V "$VOLUM_NAME" -p "$PREPARED" -input-charset iso8859-1 \
		-boot-info-table $2
	if [ -x /usr/bin/isohybrid ]; then
		echo -n "Create hybrid ISO..."
		/usr/bin/isohybrid $1 2> /dev/null
		status
	fi
}

# Generate a new ISO image using isolinux.
gen_livecd_isolinux()
{
	# Some packages may want to alter iso
	genisohooks iso
	if [ ! -f "$ROOTCD/boot/isolinux/isolinux.bin" ]; then
		echo -e "\nUnable to find isolinux binary.\n"
		cleanup
		exit 0
	fi
	# Set date for boot msg.
	if grep -q 'XXXXXXXX' $ROOTCD/boot/isolinux/isolinux.msg; then
		DATE=`date +%Y%m%d`
		echo -n "Setting build date to: $DATE..."
		sed -i s/'XXXXXXXX'/"$DATE"/ $ROOTCD/boot/isolinux/isolinux.msg
		status
	fi
	cd $ROOTCD
	echo -n "Computing md5..."
	find * -type f ! -name md5sum -exec md5sum {} \; > md5sum
	status
	cd $DISTRO
	echo ""
	echo -e "\033[1mGenerating ISO image\033[0m"
	echo "================================================================================"
	create_iso $ISO_NAME.iso $ROOTCD
	echo -n "Creating the ISO md5sum..."
	md5sum $ISO_NAME.iso > $ISO_NAME.md5
	status
	echo "================================================================================"
	# Some packages may want to alter final iso
	genisohooks final
}

lzma_history_bits()
{
	local n
	local sz
	n=20	# 1Mb
	sz=$(du -sk $1 | cut -f1)
	while [ $sz -gt 1024 -a $n -lt 28 ]; do
		n=$(( $n + 1 ))
		sz=$(( $sz / 2 ))
	done
	echo $n
}

# Pack rootfs
pack_rootfs()
{
	( cd $1 ; find . -print | cpio -o -H newc ) | \
	if [ "$COMPRESSION" = "none" ]; then
		echo -n "Generating uncompressed initramfs... "
		cat > $2
	elif [ -x /usr/bin/lzma -a "$COMPRESSION" != "gzip" ]; then
		echo -n "Generating lzma'ed initramfs... "
		lzma e -si -so -d$(lzma_history_bits $1) > $2
	else
		echo -n "Generating gziped initramfs... "
		gzip -9 > $2
	fi
}

# Generate a new initramfs from the root filesystem.
gen_initramfs()
{
	# Just in case CTRL+c
	rm -f $DISTRO/gen
	# Some packages may want to alter rootfs
	genisohooks rootfs
	cd $ROOTFS
	echo ""

        # Link duplicate files
        find . -type f -size +0c -exec stat -c '%s-%a-%u-%g %i %h %n' {} \; | \
           sort | ( save=0; old_attr=""; old_inode=""; old_link=""; old_file=""
           while read attr inode link file; do
               if [ "$attr" = "$old_attr" -a "$inode" != "$old_inode" ]; then
                   if cmp "$file" "$old_file" >/dev/null; then
                       rm -f "$file"
                       ln "$old_file" "$file"
                       inode="$old_inode"
                       [ "$link" = "1" ] && save="$(expr $save + ${attr%%-*})"
                   fi
               fi
               old_attr="$attr" ; old_inode="$inode" ; old_file="$file"
           done
           echo "$save bytes saved in duplicate files."
        )

	# Use lzma if installed
	pack_rootfs . $DISTRO/$INITRAMFS
	cd $DISTRO
	mv $INITRAMFS $ROOTCD/boot
}

distro_sizes()
{
	echo "Build date      : `date +%Y%m%d\ \at\ \%H:%M:%S`"
	echo "Packages        : `ls -1 $ROOTFS$INSTALLED | wc -l`"
	echo "Rootfs size     : `du -sh $ROOTFS | awk '{ print $1 }'`"
	echo "Initramfs size  : `du -sh $ROOTCD/boot/$INITRAMFS | awk '{ print $1 }'`"
	echo "ISO image size  : `du -sh $ISO_NAME.iso | awk '{ print $1 }'`"
	echo "================================================================================"
	echo "Image is ready: $ISO_NAME.iso"
	echo ""
}

# Print ISO and rootfs size.
distro_stats()
{
	echo ""
	echo -e "\033[1mDistro statistics\033[0m ($DISTRO)"
	echo "================================================================================"
	distro_sizes
}

# Create an empty configuration file.
empty_config_file()
{
	cat >> tazlito.conf << "EOF"
# tazlito.conf: Tazlito (SliTaz Live Tool)
# configuration file.
#

# Name of the ISO image to generate.
ISO_NAME=""

# ISO image volume name.
VOLUM_NAME="SliTaz"

# Name of the preparer.
PREPARED="$USER"

# Path to the packages repository and the packages.list.
PACKAGES_REPOSITORY=""

# Path to the distro tree to gen-distro from a
# list of packages.
DISTRO=""

# Path to the directory containing additional files
# to copy into the rootfs and rootcd of the LiveCD.
ADDFILES="$DISTRO/addfiles"

# Default answer for binary question (Y or N)
DEFAULT_ANSWER="ASK"

# Compression utility (lzma, gzip or none)
COMPRESSION="lzma"
EOF
}

# extract rootfs.gz somewhere
extract_rootfs()
{
	(zcat $1 || unlzma -c $1 || cat $1) 2>/dev/null | \
		(cd $2; cpio -idm > /dev/null)
}

# Remove duplicate files
mergefs()
{
	# merge symlinks files and devices
	( cd $1; find ) | while read file; do
		if [ -L $1/$file ]; then
			[ -L $2/$file ] &&
			[ "$(readlink $1/$file)" == "$(readlink $2/$file)" ] &&
			rm -f $2/$file
		elif [ -f $1/$file ]; then
			[ -f $2/$file ] &&
			cmp $1/$file $2/$file > /dev/null 2>&1 && rm -f $2/$file
			[ -f $2/$file ] && 
			[ "$(basename $file)" == "volatile.cpio.gz" ] &&
			[ "$(dirname $(dirname $file))" == \
			  "./var/lib/tazpkg/installed" ] && rm -f $2/$file
		elif [ -b $1/$file ]; then
			[ -b $2/$file ] && rm -f $2/$file
		elif [ -c $1/$file ]; then
			[ -c $2/$file ] && rm -f $2/$file
		fi
	done
	
	# cleanup directories
	( cd $1; find ) | while read file; do
		if [ -d $1/$file ]; then
			[ -d $2/$file ] && rmdir $2/$file 2> /dev/null
		fi
	done
	true
}

cleanup_merge()
{
	rm -rf $TMP_DIR
	exit 1
}

####################
# Tazlito commands #
####################

case "$COMMAND" in
	stats)
		# Tazlito general statistics from the config file.
		#
		echo ""
		echo -e "\033[1mTazlito statistics\033[0m
===============================================================================
Config file         : $CONFIG_FILE
ISO name            : $ISO_NAME.iso
Volume name         : $VOLUM_NAME
Prepared            : $PREPARED
Packages repository : $PACKAGES_REPOSITORY
Distro directory    : $DISTRO"
		if [ ! "$ADDFILES" = "" ] ; then
			echo -e "Additional files    : $ADDFILES"
		fi
		echo "================================================================================"
		echo ""
	    ;;
	gen-config)
		# Generate a new config file in the current dir or the specified
		# directory by $2.
		#
		if [ -n "$2" ] ; then
			mkdir -p $2 && cd $2
		fi
		echo -n "Generating empty tazlito.conf..."
		empty_config_file
		status
		echo ""
		if [ -f "tazlito.conf" ] ; then
			echo "Configuration file is ready to edit."
			echo "File location : `pwd`/tazlito.conf"
			echo ""
		fi
		;;
	configure)
		# Configure a tazlito.conf config file. Start by getting
		# a empty config file and sed it.
		#
		if [ -f "tazlito.conf" ] ; then
			rm tazlito.conf
		else
			if test $(id -u) = 0 ; then
				cd /etc
			else
				echo "You must be root to configure the main config file or in"
				echo "the same directory of the file you want to configure."
				exit 0
			fi
		fi
		empty_config_file
		echo""
		echo -e "\033[1mConfiguring :\033[0m `pwd`/tazlito.conf"
		echo "================================================================================"
		# ISO name.
		echo -n "ISO name            : " ; read answer
		sed -i s#'ISO_NAME=\"\"'#"ISO_NAME=\"$answer\""# tazlito.conf
		# Volume name.
		echo -n "Volume name         : " ; read answer
		sed -i s/'VOLUM_NAME=\"SliTaz\"'/"VOLUM_NAME=\"$answer\""/ tazlito.conf
		# Packages repository.
		echo -n "Packages repository : " ; read answer
		sed -i s#'PACKAGES_REPOSITORY=\"\"'#"PACKAGES_REPOSITORY=\"$answer\""# tazlito.conf
		# Distro path.
		echo -n "Distro path         : " ; read answer
		sed -i s#'DISTRO=\"\"'#"DISTRO=\"$answer\""# tazlito.conf
		echo "================================================================================"
		echo "Config file is ready to use."
		echo "You can now extract an ISO or generate a distro."
		echo ""
		;;
	gen-iso)
		# Simply generate a new iso.
		#
		check_root
		verify_rootcd
		gen_livecd_isolinux
		distro_stats
		;;
	gen-initiso)
		# Simply generate a new initramfs with a new iso.
		#
		check_root
		verify_rootcd
		gen_initramfs
		gen_livecd_isolinux
		distro_stats
		;;
	extract-distro)
		# Extract an ISO image to a directory and rebuild the LiveCD tree.
		#
		check_root
		ISO_IMAGE=$2
		if [ -z "$ISO_IMAGE" ] ; then
			echo -e "\nPlease specify the path to the ISO image."
			echo -e "Example : `basename $0` image.iso /path/target\n"
			exit 0
		fi
		# Set the distro path by checking for $3 on cmdline.
		if [ -n "$3" ] ; then
			TARGET=$3
		else
			TARGET=$DISTRO
		fi
		# Exit if existing distro is found.
		if [ -d "$TARGET/rootfs" ] ; then
			echo -e "\nA rootfs exists in : $TARGET"
			echo -e "Please clean the distro tree or change directory path.\n"
			exit 0
		fi
		echo ""
		echo -e "\033[1mTazlito extracting :\033[0m `basename $ISO_IMAGE`"
		echo "================================================================================"
		# Start to mount the ISO.
		echo ""
		echo "Mounting ISO image..."
		mkdir -p $TMP_DIR
		# Get ISO file size.
		isosize=`du -sh $ISO_IMAGE | cut -f1`
		mount -o loop $ISO_IMAGE $TMP_DIR
		sleep 2
		# Prepare target dir, copy the kernel and the rootfs.
		mkdir -p $TARGET/rootfs
		mkdir -p $TARGET/rootcd/boot
		echo -n "Copying the Linux kernel..."
		if cp $TMP_DIR/boot/vmlinuz* $TARGET/rootcd/boot 2> /dev/null; then
			ln $TARGET/rootcd/boot/vmlinuz* $TARGET/rootcd/boot/bzImage
		else
			cp $TMP_DIR/boot/bzImage $TARGET/rootcd/boot
		fi
		status
		echo -n "Copying isolinux files..."
		cp -a $TMP_DIR/boot/isolinux $TARGET/rootcd/boot
		for i in $(ls $TMP_DIR); do
			[ "$i" = "boot" ] && continue
			cp -a $TMP_DIR/$i $TARGET/rootcd
		done
		status
		if [ -d $TMP_DIR/boot/syslinux ]; then
			echo -n "Copying syslinux files..."
			cp -a $TMP_DIR/boot/syslinux $TARGET/rootcd/boot
			status
		fi
		if [ -d $TMP_DIR/boot/extlinux ]; then
			echo -n "Copying extlinux files..."
			cp -a $TMP_DIR/boot/extlinux $TARGET/rootcd/boot
			status
		fi
		if [ -d $TMP_DIR/boot/grub ]; then
			echo -n "Copying GRUB files..."
			cp -a $TMP_DIR/boot/grub $TARGET/rootcd/boot
			status
		fi
		
		echo -n "Copying the rootfs..."
		cp $TMP_DIR/boot/rootfs.?z $TARGET/rootcd/boot
		status
		# Extract initramfs.
		cd $TARGET/rootfs
		echo -n "Extracting the rootfs... "
		extract_rootfs ../rootcd/boot/rootfs.gz $TARGET/rootfs
		# unpack /usr
		for i in etc/tazlito/*.extract; do
			[ -f "$i" ] && . $i ../rootcd
		done
		# Umount and remove temp directory and cd to $TARGET to get stats.
		umount $TMP_DIR && rm -rf $TMP_DIR
		cd ..
		echo ""
		echo "================================================================================"
		echo "Extracted       : `basename $ISO_IMAGE` ($isosize)"
		echo "Distro tree     : `pwd`"
		echo "Rootfs size     : `du -sh rootfs`"
		echo "Rootcd size     : `du -sh rootcd`"
		echo "================================================================================"
		echo ""
		;;
	list-flavors)
		# Show available flavors.
		if [ ! -s /etc/tazlito/flavors.list -o "$2" == "--recharge" ]; then
			download flavors.list -O - > /etc/tazlito/flavors.list
		fi
		echo ""
		echo -e "\033[1mList of flavors\033[0m"
		echo "================================================================================"
		cat /etc/tazlito/flavors.list
		echo ""
		;;
	show-flavor)
		# Show flavor description.
		FLAVOR=${2%.flavor}
		if [ ! -f "$FLAVOR.flavor" ]; then
			echo "File $FLAVOR.flavor not found."
			exit 1
		fi
		mkdir $TMP_DIR
		zcat $FLAVOR.flavor | ( cd $TMP_DIR; cpio -i 2> /dev/null )
		if [ "$3" = "--brief" ]; then
			if [ "$4" != "--noheader" ]; then
				echo "Name            Sizes        Description"
				echo "================================================================================"
			fi
			printf "%-15.15s %5.5s/%5.5s %-51s\n" "$FLAVOR" \
				"$(field ISO $TMP_DIR/$FLAVOR.desc)" \
				"$(field Rootfs $TMP_DIR/$FLAVOR.desc)" \
				"$(grep ^Description $TMP_DIR/$FLAVOR.desc | cut -d: -f2)"
		else
			echo "================================================================================"
			cat $TMP_DIR/$FLAVOR.desc
		fi
		rm -Rf $TMP_DIR
		;;
	gen-liveflavor)
		# Generate a new flavor form the live system.
		FLAVOR=${2%.flavor}
		DESC=""
		case "$FLAVOR" in
		'')	echo -n "Flavor name : "
			read FLAVOR
			[ -z "$FLAVOR" ] && exit 1;;
		-?|-h*|--help) echo -e "

SliTaz Live Tool - Version: $VERSION
\033[1mUsage: \033[0m `basename $0` gen-liveflavor flavor-name [flavor-patch-file]
\033[1mflavor-patch-file format: \033[0m
code	data
+	package to add
-	package to remove
!	non-free package to add
?	display message
@	flavor description

\033[1mExample: \033[0m
@	Developer tools for slitaz maintainers
+	slitaz-toolchain
+	mercurial
"
			exit 1;;
		esac
		mv /etc/tazlito/distro-packages.list \
		   /etc/tazlito/distro-packages.list.$$ 2> /dev/null
		rm -f distro-packages.list non-free.list 2> /dev/null
		tazpkg recharge
		[ -n "$3" ] && while read action pkg; do
			case "$action" in
			+)	yes | tazpkg get-install $pkg;;
			-)	yes | tazpkg remove $pkg;;
			!)	echo $pkg >> non-free.list;;
			@)	DESC="$pkg";;
			\?)	echo -en "$pkg"; read action;;
			esac
		done < $3
		yes '' | tazlito gen-distro
		echo "$DESC" | tazlito gen-flavor "$FLAVOR"
		mv /etc/tazlito/distro-packages.list.$$ \
		   /etc/tazlito/distro-packages.list 2> /dev/null
		;;
	gen-flavor)
		# Generate a new flavor from the last iso image generated.
		FLAVOR=${2%.flavor}
		echo ""
		echo -e "\033[1mFlavor generation\033[0m"
		echo "================================================================================"
		if [ -z "$FLAVOR" ]; then
			echo -n "Flavor name : "
			read FLAVOR
			[ -z "$FLAVOR" ] && exit 1
		fi
		check_rootfs
		FILES="$FLAVOR.pkglist"
		echo -n "Creating file $FLAVOR.flavor..."
		for i in rootcd rootfs; do
			if [ -d "$ADDFILES/$i" ] ; then
				FILES="$FILES\n$FLAVOR.$i"
				( cd "$ADDFILES/$i"; find . | \
				  cpio -o -H newc 2> /dev/null | gzip -9 ) > $FLAVOR.$i
			fi
		done
		status
		answer=`grep -s ^Description $FLAVOR.desc`
		answer=${answer#Description     : }
		if [ -z "$answer" ]; then
			echo -n "Description : "
			read answer
		fi
		echo -n "Compressing flavor $FLAVOR..."
		echo "Flavor          : $FLAVOR" > $FLAVOR.desc
		echo "Description     : $answer" >> $FLAVOR.desc
		( cd $DISTRO; distro_sizes) >> $FLAVOR.desc
		\rm -f $FLAVOR.pkglist $FLAVOR.nonfree 2> /dev/null
		for i in $(ls $ROOTFS$INSTALLED); do
			eval $(grep ^VERSION= $ROOTFS$INSTALLED/$i/receipt)
			EXTRAVERSION=""
			eval $(grep ^EXTRAVERSION= $ROOTFS$INSTALLED/$i/receipt)
			eval $(grep ^CATEGORY= $ROOTFS$INSTALLED/$i/receipt)
			if [ "$CATEGORY" = "non-free" -a "${i%%-*}" != "get" ]
			then
				echo "$i" >> $FLAVOR.nonfree
			else
				echo "$i-$VERSION$EXTRAVERSION" >> $FLAVOR.pkglist
			fi
		done
		[ -s $FLAVOR.nonfree ] && $FILES="$FILES\n$FLAVOR.nonfree"
		echo -e "$FLAVOR.desc\n$FILES" | cpio -o -H newc 2>/dev/null | \
			gzip -9 > $FLAVOR.flavor
		rm `echo -e $FILES`
		status
		echo "================================================================================"
		echo "Flavor size : `du -sh $FLAVOR.flavor`"
		echo ""
		;;
	upgrade-flavor)
		# Update package list to the lastest versions available.
		FLAVOR=${2%.flavor}
		if [ -f $FLAVOR.flavor ] || download $FLAVOR.flavor; then
			mkdir $TMP_DIR
			zcat $FLAVOR.flavor | ( cd $TMP_DIR; cpio -i >/dev/null )
			echo -n "Update $FLAVOR package list..."
			sed -i -e 's/size\( *:\) \(.*\)/size\1 unknown/' \
			       -e 's/is ready/not built yet/' \
			       -e 's/date\( *:\) \(.*\)/date\1 not built yet/' \
					$TMP_DIR/$FLAVOR.desc
			[ -s /var/lib/tazpkg/packages.list ] || tazpkg recharge
			while read org; do
				i=0
				pkg=$org
				while ! grep -q ^$pkg$ /var/lib/tazpkg/packages.txt; do
					pkg=${pkg%-*}
					i=$(($i + 1))
					[ $i -gt 5 ] && break;
				done
				for i in $(grep ^$pkg /var/lib/tazpkg/packages.list); do
					echo $i
					break
				done
			done <  $TMP_DIR/$FLAVOR.pkglist \
			     > $TMP_DIR/$FLAVOR.pkglist.$$
			mv -f $TMP_DIR/$FLAVOR.pkglist.$$ $TMP_DIR/$FLAVOR.pkglist
			( cd $TMP_DIR ; ls | cpio -o -H newc ) | gzip -9 > \
				$FLAVOR.flavor
			status
			rm -Rf $TMP_DIR
		fi
		;;
	extract-flavor)
		# Extract a flavor into $FLAVORS_REPOSITORY.
		FLAVOR=${2%.flavor}
		if [ -f $FLAVOR.flavor ] || download $FLAVOR.flavor; then
			mkdir $TMP_DIR
			zcat $FLAVOR.flavor | ( cd $TMP_DIR; cpio -i >/dev/null )
			echo -n "Extract $FLAVOR..."
			rm -rf $FLAVORS_REPOSITORY/$FLAVOR 2> /dev/null
			mkdir -p $FLAVORS_REPOSITORY/$FLAVOR
			grep ^Description $TMP_DIR/$FLAVOR.desc | \
				sed 's/.*: \(.*\)$/\1/' > \
				$FLAVORS_REPOSITORY/$FLAVOR/desc.txt
			for i in rootcd rootfs; do
				[ -f $TMP_DIR/$FLAVOR.$i ] || continue
				mkdir $FLAVORS_REPOSITORY/$FLAVOR/$i
				zcat $TMP_DIR/$FLAVOR.$i | \
				  (cd $FLAVORS_REPOSITORY/$FLAVOR/$i; \
				   cpio -idm > /dev/null)
			done
			[ -s /var/lib/tazpkg/packages.list ] || tazpkg recharge
			while read org; do
				i=0
				pkg=$org
				while ! grep -q ^$pkg$ /var/lib/tazpkg/packages.txt; do
					pkg=${pkg%-*}
					i=$(($i + 1))
					[ $i -gt 5 ] && break;
				done
				echo $pkg
			done <  $TMP_DIR/$FLAVOR.pkglist \
			     > $FLAVORS_REPOSITORY/$FLAVOR/pkglist.txt
			status
			rm -Rf $TMP_DIR
		fi
		;;
	pack-flavor)
		# Create a flavor from $FLAVORS_REPOSITORY.
		FLAVOR=${2%.flavor}
		if [ -s $FLAVORS_REPOSITORY/$FLAVOR/desc.txt ]; then
			mkdir $TMP_DIR
			echo -n "Create $FLAVOR..."
			cat > $TMP_DIR/$FLAVOR.desc <<EOT
Flavor          : $FLAVOR
Description     : $(grep -v ^# $FLAVORS_REPOSITORY/$FLAVOR/desc.txt)
Build date      : $(date +%Y%m%d\ \at\ \%H:%M:%S)
Packages        : $(grep -v ^# $FLAVORS_REPOSITORY/$FLAVOR/pkglist.txt | wc -l)
Rootfs size     : unknown
Initramfs size  : unknown
ISO image size  : unknown
================================================================================

EOT
			[ -s /var/lib/tazpkg/packages.list ] || tazpkg recharge
			grep -v ^#  $FLAVORS_REPOSITORY/$FLAVOR/pkglist.txt | \
			while read pkg; do
				for i in $(grep ^$pkg /var/lib/tazpkg/packages.list); do
					echo $i
					break
				done
			done > $TMP_DIR/$FLAVOR.pkglist
			for i in rootcd rootfs; do
				[ -d $FLAVORS_REPOSITORY/$FLAVOR/$i ] || \
					continue
				( cd $FLAVORS_REPOSITORY/$FLAVOR/$i ; find . | \
				cpio -o -H newc ) | gzip -9 >$TMP_DIR/$FLAVOR.$i
			done
			( cd $TMP_DIR ; ls | cpio -o -H newc ) | gzip -9 > \
				$FLAVOR.flavor
			status
			rm -Rf $TMP_DIR
		fi
		;;
	get-flavor)
		# Get a flavor's files and prepare for gen-distro.
		FLAVOR=${2%.flavor}
		if [ -f $FLAVOR.flavor ] || download $FLAVOR.flavor; then
			echo -n "Cleaning $DISTRO..."
			rm -R $DISTRO 2> /dev/null
			mkdir -p $DISTRO
			status
			mkdir $TMP_DIR
			zcat $FLAVOR.flavor | ( cd $TMP_DIR; cpio -i 2>/dev/null )
			echo -n "Create distro-packages.list..."
			mv $TMP_DIR/$FLAVOR.nonfree non-free.list 2> /dev/null
			mv $TMP_DIR/$FLAVOR.pkglist distro-packages.list
			status
			for i in rootcd rootfs; do
				if [ -f $TMP_DIR/$FLAVOR.$i ]; then
					mkdir -p "$ADDFILES/$i"
					zcat $TMP_DIR/$FLAVOR.$i | \
						( cd "$ADDFILES/$i"; cpio -id 2> /dev/null)
				fi
			done
			echo -n "Update tazlito.conf..."
			[ -f tazlito.conf ] || cp /etc/tazlito/tazlito.conf .
			cat tazlito.conf | grep -v "^#VOLUM_NAME" | \
			sed "s/^VOLUM_NA/VOLUM_NAME=\"SliTaz $FLAVOR\"\\n#VOLUM_NA/" \
				> tazlito.conf.$$ && mv tazlito.conf.$$ tazlito.conf
			status
			rm -Rf $TMP_DIR
		fi
		;;
	check-list)
		# Use current packages list in $PWD by default.
		DISTRO_PKGS_LIST=distro-packages.list
		[ -d "$2" ] && DISTRO_PKGS_LIST=$2/distro-packages.list
		[ -f "$2" ] && DISTRO_PKGS_LIST=$2
		[ ! -f $DISTRO_PKGS_LIST ] && echo "No packages list found." && exit 0
		echo ""
		echo -e "\033[1mLiveCD packages list check\033[0m"
		echo "================================================================================"
		for pkg in `cat $DISTRO_PKGS_LIST`
		do
			if ! grep -q "$pkg" /var/lib/tazpkg/packages.list; then
				echo "Update: $pkg"
				up=$(($up + 1))
			fi
		done
		[ -z $up ] && echo -e "List is up-to-date\n" && exit 0
		echo "================================================================================"
		echo -e "Updates: $up\n" ;;
	gen-distro)
		# Generate a live distro tree with a set of packages.
		#
		check_root
		
		# Check if a package list was specified on cmdline.
		LIST_NAME="distro-packages.list"
		CDROM=""
		while [ -n "$2" ]; do
			case "$2" in
			--iso=*)
				CDROM="-o loop ${2#--iso=}"
				;;
			--cdrom)
				CDROM="/dev/cdrom"
				;;
			--force)
				DELETE_ROOTFS="true"
				;;
			*)	if [ ! -f "$2" ] ; then
					echo -e "\nUnable to find the specified packages list."
					echo -e "List name : $2\n"
					exit 1
				fi
				LIST_NAME=$2
				;;
			esac
			shift
		done
		 
		if [ -d $ROOTFS ] ; then
			# Delete $ROOTFS if --force is set on command line
			if [ ! -z $DELETE_ROOTFS ]; then
				rm -rf $ROOTFS
				unset $DELETE_ROOTFS
			else
				echo -e "\nA rootfs exists in : $DISTRO"
				echo -e "Please clean the distro tree or change directory path.\n"
				exit 0
			fi
		fi
		if [ ! -f "$LIST_NAME" -a -d $INSTALLED ] ; then
		# Build list with installed packages
			for i in $(ls $INSTALLED); do
				eval $(grep ^VERSION= $INSTALLED/$i/receipt)
				EXTRAVERSION=""
				eval $(grep ^EXTRAVERSION= $INSTALLED/$i/receipt)
				echo "$i-$VERSION$EXTRAVERSION" >> $LIST_NAME
			done
		fi
		# Exit if no list name.
		if [ ! -f "$LIST_NAME" ]; then
			echo -e "\nNo packages list found or specified. Please read the docs.\n"
			exit 0
		fi
		# Start generation.
		echo ""
		echo -e "\033[1mTazlito generating a distro\033[0m"
		echo "================================================================================"
		# Misc checks
		[ -n "$PACKAGES_REPOSITORY" ] || PACKAGES_REPOSITORY="."
		[ -d $PACKAGES_REPOSITORY ] || mkdir -p $PACKAGES_REPOSITORY
		# Get the list of packages using cat for a file list.
		LIST=`cat $LIST_NAME`
		# Verify if all packages in list are present in $PACKAGES_REPOSITORY.
		REPACK=""
		DOWNLOAD=""
		for pkg in $LIST
		do
			[ "$pkg" = "" ] && continue
			pkg=${pkg%.tazpkg}
			[ -f $PACKAGES_REPOSITORY/$pkg.tazpkg ] && continue
			PACKAGE=$(installed_package_name $pkg)
			[ -n "$PACKAGE" -a "$REPACK" = "y" ] && continue
			[ -z "$PACKAGE" -a -n "$DOWNLOAD" ] && continue
			echo -e "\nUnable to find $pkg in the repository."
			echo -e "Path : $PACKAGES_REPOSITORY\n"
			if [ -n "$PACKAGE" -a -z "$REPACK" ]; then
				yesorno "Repack packages from rootfs (y/N) ? "
				REPACK="$answer"
				[ "$answer" = "y" ] || REPACK="n"
				[ "$DOWNLOAD" = "y" ] && break
			fi
			if [ -f $MIRROR -a -z "$DOWNLOAD" ]; then
				yesorno "Download packages from mirror (Y/n) ? "
				DOWNLOAD="$answer"
				if [ "$answer" = "n" ]; then
					[ -z "$PACKAGE" ] && exit 1
				else
					DOWNLOAD="y"
					[ -n "$REPACK" ] && break
				fi
			fi
			[ "$REPACK" = "n" -a "$DOWNLOAD" = "n" ] && exit 1
		done
		
		# Mount cdrom to be able to repack boot-loader packages
		if [ ! -e /boot -a -n "$CDROM" ]; then
			mkdir $TMP_MNT
			if mount -r $CDROM $TMP_MNT 2> /dev/null; then
				ln -s $TMP_MNT/boot /
				if [ ! -d "$ADDFILES/rootcd" ] ; then
					mkdir -p $ADDFILES/rootcd
					for i in $(ls $TMP_MNT); do
						[ "$i" = "boot" ] && continue
						cp -a $TMP_MNT/$i $ADDFILES/rootcd
					done
				fi
			else
				rmdir $TMP_MNT
			fi
		fi

		# Root fs stuff.
		echo "Preparing the rootfs directory..."
		mkdir -p $ROOTFS
		sleep 2
		for pkg in $LIST
		do
			[ "$pkg" = "" ] && continue
			# First copy and extract the package in tmp dir.
			pkg=${pkg%.tazpkg}
			PACKAGE=$(installed_package_name $pkg)
			mkdir -p $TMP_DIR
			if [ ! -f $PACKAGES_REPOSITORY/$pkg.tazpkg ]; then
				# Look for package in cache
				if [ -f $CACHE_DIR/$pkg.tazpkg ]; then
					ln -s $CACHE_DIR/$pkg.tazpkg $PACKAGES_REPOSITORY
				# Look for package in running distribution
				elif [ -n "$PACKAGE" -a "$REPACK" = "y" ]; then
					tazpkg repack $PACKAGE && \
					  mv $pkg.tazpkg $PACKAGES_REPOSITORY 
				fi
			fi
			if [ ! -f $PACKAGES_REPOSITORY/$pkg.tazpkg ]; then
				# Get package from mirror
				[ "$DOWNLOAD" = "y" ] && \
				download $pkg.tazpkg && \
				mv $pkg.tazpkg $PACKAGES_REPOSITORY
			fi
			if [ ! -f $PACKAGES_REPOSITORY/$pkg.tazpkg ]; then
				echo "Missing package $pkg."
				cleanup
				exit 1
			fi
		done
		if [ -f non-free.list ]; then
			echo "Preparing non-free packages..."
			cp non-free.list $ROOTFS/etc/tazlito/non-free.list
			for pkg in $(cat non-free.list); do
				if [ ! -d $INSTALLED/$pkg ]; then
					if [ ! -d $INSTALLED/get-$pkg ]; then
						tazpkg get-install get-$pkg
					fi
					get-$pkg
				fi
				tazpkg repack $pkg
				pkg=$(ls $pkg*.tazpkg)
				grep -q "^$pkg$" $LIST_NAME || \
					echo $pkg >>$LIST_NAME
				mv $pkg $PACKAGES_REPOSITORY 
			done
		fi
		echo ""
		cp $LIST_NAME $DISTRO/distro-packages.list
		sed 's/\(.*\)/\1.tazpkg/' < $DISTRO/distro-packages.list > $DISTRO/list-packages
		cd $PACKAGES_REPOSITORY
		yes y | tazpkg install-list \
			$DISTRO/list-packages --root=$ROOTFS
		cd $DISTRO
		cp distro-packages.list $ROOTFS/etc/tazlito
		# Copy all files from $ADDFILES/rootfs to the rootfs.
		if [ -d "$ADDFILES/rootfs" ] ; then
			echo -n "Copying addfiles content to the rootfs... "
			cp -a $ADDFILES/rootfs/* $ROOTFS
			status
		fi
		echo "Root file system is generated..."
		# Root CD part.
		echo -n "Preparing the rootcd directory..."
		mkdir -p $ROOTCD
		status
		# Move the boot dir with the Linux kernel from rootfs.
		# The boot dir goes directly on the CD.
		if [ -d "$ROOTFS/boot" ] ; then
			echo -n "Moving the boot directory..."
			mv $ROOTFS/boot $ROOTCD
			cd $ROOTCD/boot
			ln vmlinuz-* bzImage
			status
		fi
		cd $DISTRO
		# Copy all files from $ADDFILES/rootcd to the rootcd.
		if [ -d "$ADDFILES/rootcd" ] ; then
			echo -n "Copying addfiles content to the rootcd... "
			cp -a $ADDFILES/rootcd/* $ROOTCD
			status
		fi
		# Execute the distro script (used to perform tasks in the rootfs
		# before compression. Give rootfs path in arg
		[ -z $DISTRO_SCRIPT ] && DISTRO_SCRIPT=$TOP_DIR/distro.sh
		if [ -x $DISTRO_SCRIPT ]; then
			echo "Executing distro script..."
			sh $DISTRO_SCRIPT $DISTRO
		fi
		# Initramfs and ISO image stuff.
		gen_initramfs
		gen_livecd_isolinux
		distro_stats
		cleanup
		;;
	clean-distro)
		# Remove old distro tree.
		#
		check_root
		echo ""
		echo -e "\033[1mCleaning :\033[0m $DISTRO"
		echo "================================================================================"
		if [ -d "$DISTRO" ] ; then
			if [ -d "$ROOTFS" ] ; then
				echo -n "Removing the rootfs..."
				rm -f $DISTRO/$INITRAMFS
				rm -rf $ROOTFS
				status
			fi
			if [ -d "$ROOTCD" ] ; then
				echo -n "Removing the rootcd..."
				rm -rf $ROOTCD
				status
			fi
			echo -n "Removing eventual ISO image..."
			rm -f $DISTRO/$ISO_NAME.iso
			rm -f $DISTRO/$ISO_NAME.md5
			status
		fi
		echo "================================================================================"
		echo ""
		;;
	check-distro)
		# Check for a few LiveCD needed files not installed by packages.
		#
		check_rootfs
		echo ""
		echo -e "\033[1mChecking distro :\033[0m $ROOTFS"
		echo "================================================================================"
		# SliTaz release info.
		if [ ! -f "$ROOTFS/etc/slitaz-release" ]; then
			echo "Missing release info : /etc/slitaz-release"
		else
			release=`cat $ROOTFS/etc/slitaz-release`
			echo -n "Release      : $release"
			status
		fi
		# Tazpkg mirror.
		if [ ! -f "$ROOTFS/var/lib/tazpkg/mirror" ]; then
			echo -n "Mirror URL   : Missing /var/lib/tazpkg/mirror"
			todomsg
		else
			echo -n "Mirror configuration exist..."
			status
		fi
		# Isolinux msg	
		if grep -q "cooking-XXXXXXXX" /$ROOTCD/boot/isolinux/isolinux.msg; then
			echo -n "Isolinux msg : Missing cooking date XXXXXXXX (ex `date +%Y%m%d`)"
			todomsg
		else
			echo -n "Isolinux message seems good..."
			status
		fi
		echo "================================================================================"
		echo ""
		;;
	burn-iso)
		# Guess cdrom device, ask user and burn the ISO.
		#
		check_root
		DRIVE_NAME=`cat /proc/sys/dev/cdrom/info | grep "drive name" | cut -f 3`
		DRIVE_SPEED=`cat /proc/sys/dev/cdrom/info | grep "drive speed" | cut -f 3`
		# We can specify an alternative ISO from the cmdline.
		if [ -n "$2" ] ; then
			iso=$2
		else
			iso=$DISTRO/$ISO_NAME.iso
		fi
		if [ ! -f "$iso" ]; then
			echo -e "\nUnable to find ISO : $iso\n"
			exit 0
		fi
		echo ""
		echo -e "\033[1mTazlito burn ISO\033[0m "
		echo "================================================================================"
		echo "Cdrom device  : /dev/$DRIVE_NAME"
		echo "Drive speed   : $DRIVE_SPEED"
		echo "ISO image     : $iso"
		echo "================================================================================"
		echo ""
		yesorno "Burn ISO image (y/N) ? "
		if [ "$answer" == "y" ]; then
			echo ""
			echo "Starting Wodim to burn the iso..." && sleep 2
			echo "================================================================================"
			wodim speed=$DRIVE_SPEED dev=/dev/$DRIVE_NAME $iso
			echo "================================================================================"
			echo "ISO image is burned to cdrom."
		else
			echo -e "\nExiting. No ISO burned."
		fi
		echo ""
		;;
	merge)
		# Merge multiple rootfs into one iso.
		#
		if [ -z "$2" ]; then
			cat << EOT
Usage: tazlito merge size1 iso size2 rootfs2 [sizeN rootfsN]...

Merge multiple rootfs into one iso. Rootfs are like russian dolls
i.e: rootfsN is a subset of rootfsN-1
rootfs1 is found in iso, sizeN is the RAM size need to launch rootfsN.
The boot loader will select the rootfs according to the RAM size detected.

Example: 
$ tazlito merge 160M slitaz-core.iso 96M rootfs-justx.gz 32M rootfs-base.gz

Will start slitaz-core with 160M+ RAM, slitaz-justX with 96M-160M RAM,
slitaz-base with 32M-96M RAM and display an error message if RAM < 32M.
EOT
			exit 2
		fi

		shift	# skip merge
		append="append $(( (${1%M} - 3) * 1024 )) slitaz1"
		shift	# skip size1
		mkdir -p $TMP_DIR/mnt $TMP_DIR/rootfs1

		ISO=$1.merged
		# Extract filesystems
		echo -n "Mount $1"
		mount -o loop,ro $1 $TMP_DIR/mnt 2> /dev/null
		status || cleanup_merge
		cp -a $TMP_DIR/mnt $TMP_DIR/iso
		rm -f $TMP_DIR/iso/boot/bzImage
		ln $TMP_DIR/iso/boot/vmlinuz* $TMP_DIR/iso/boot/bzImage
		umount -d $TMP_DIR/mnt
		if [ -f $TMP_DIR/iso/boot/rootfs1.gz ]; then
			echo "$1 is already a merged iso. Abort."
			cleanup_merge
		fi
		if [ ! -f $TMP_DIR/iso/boot/isolinux/ifmem.c32 ]; then
			if [ ! -f /boot/isolinux/ifmem.c32 ]; then
				cat <<EOT
No file /boot/isolinux/ifmem.c32
Please install syslinux package !
EOT
				rm -rf $TMP_DIR
				exit 1
			fi
			cp /boot/isolinux/ifmem.c32 $TMP_DIR/iso/boot/isolinux
		fi
		
		echo -n "Extract iso/rootfs.gz"
		extract_rootfs $TMP_DIR/iso/boot/rootfs.gz $TMP_DIR/rootfs1 &&
		[ -d $TMP_DIR/rootfs1/etc ]
		status || cleanup_merge
		n=1
		while [ -n "$2" ]; do
			shift	# skip rootfs N-1
			p=$n
			n=$(($n + 1))
			append="$append $(( (${1%M} - 3) * 1024 )) slitaz$n"
			shift	# skip size N
			mkdir -p $TMP_DIR/rootfs$n
			echo -n "Extract $1"
			extract_rootfs $1 $TMP_DIR/rootfs$n &&
			[ -d $TMP_DIR/rootfs$n/etc ]
			status || cleanup_merge
			echo -n "Merge rootfs$n into rootfs$p"
			mergefs $TMP_DIR/rootfs$n $TMP_DIR/rootfs$p
			status
			echo "Create rootfs$p.gz"
			pack_rootfs $TMP_DIR/rootfs$p $TMP_DIR/iso/boot/rootfs$p.gz
			status
		done
		echo "Create rootfs$n.gz"
		pack_rootfs $TMP_DIR/rootfs$n $TMP_DIR/iso/boot/rootfs$n.gz
		status
		rm -f $TMP_DIR/iso/boot/rootfs.gz
	
		echo -n "Update boot files"
		grep -l 'include common' $TMP_DIR/iso/boot/isolinux/*.cfg | \
		while read file ; do
			awk -v n=$n '{
if (/label/) label=$0;
else if (/kernel/) kernel=$0;
else if (/append/) {
	i=index($0,"rootfs.gz");
	append=substr($0,i+9);
}
else if (/include/) {
	for (i = 1; i <= n; i++) {
		print label i
		print kernel;
		initrd="initrd=/boot/rootfs" n ".gz"
		for (j = n - 1; j >= i; j--) {
			initrd=initrd ",/boot/rootfs" j ".gz";
		}
		printf "\tappend %s%s\n",initrd,append;
		print "";
	}
	print;
}
else print;
}' < $file > $file.$$
			mv -f $file.$$ $file
		done
		cat >> $TMP_DIR/iso/boot/isolinux/common.cfg <<EOT
label slitaz
	kernel /boot/isolinux/ifmem.c32
	$append noram

label noram
	config noram.cfg

EOT
		cat >> $TMP_DIR/iso/boot/isolinux/noram.cfg <<EOT
display isolinux.msg
say Not enough RAM to boot slitaz.
default reboot
label reboot
	com32 reboot.c32

implicit 0
prompt 1
timeout 80
F1 help.txt
F2 options.txt
F3 isolinux.msg
F4 display.txt
F5 enhelp.txt
F6 enopts.txt
EOT
		status
		echo "Generate $ISO"
		create_iso $ISO $TMP_DIR/iso
		rm -rf $TMP_DIR
		;;

	repack)
		# Repack an iso with maximum lzma compression ratio.
		#

		ISO=$2

		mkdir -p $TMP_DIR/mnt
		# Extract filesystems
		echo -n "Mount $ISO"
		mount -o loop,ro $ISO $TMP_DIR/mnt 2> /dev/null
		status || cleanup_merge
		cp -a $TMP_DIR/mnt $TMP_DIR/iso
		umount -d $TMP_DIR/mnt
		
		for i in $TMP_DIR/iso/boot/rootfs* ; do
			echo -n "Repack $(basename $i)"
			(zcat $i || unlzma -c $i || cat $i) \
				2>/dev/null > $TMP_DIR/rootfs
			lzma e $TMP_DIR/rootfs $i \
				-d$(lzma_history_bits $TMP_DIR/rootfs)
			status
		done
		
		echo "Generate $ISO"
		create_iso $ISO $TMP_DIR/iso
		rm -rf $TMP_DIR
		;;

	usage|*)
		# Clear and print usage also for all unknown commands.
		#
		clear
		usage
		;;

esac

exit 0
