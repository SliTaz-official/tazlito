#!/bin/sh
# TazLito - SliTaz Live Tool.
#
# Tazlito is a tool to help generate and configure SliTaz LiveCD
# ISO images. You can create a custom distro in one command from a list of
# packages, extract an existing ISO image to hack it, create a new initramfs
# and/or a new ISO. Most commands must be run by root, except the stats
# and the configuration file manipulation.
#
# (C) 2007-2010 SliTaz - GNU General Public License.
#
# Authors : Christophe Lincoln <pankso@slitaz.org>
#           Pascal Bellard <pascal.bellard@slitaz.org>
#
VERSION=2.0

# Tazlito configuration variables to be shorter
# and to use words rather than numbers.
COMMAND=$1
LIST_NAME=$2
TMP_DIR=/tmp/tazlito-$$-$RANDOM
TMP_MNT=/media/tazlito-$$-$RANDOM
TOP_DIR=`pwd`
INITRAMFS=rootfs.gz
LOCALSTATE=/var/lib/tazpkg
INSTALLED=$LOCALSTATE/installed
CACHE_DIR=/var/cache/tazpkg
MIRROR=$LOCALSTATE/mirror
DEFAULT_MIRROR="http://mirror.slitaz.org/packages/`cat /etc/slitaz-release`/"

# Try to include config file, continue if command is gen-config or exit.
# The main config used by default is in /etc/tazlito.
if [ -f "/etc/tazlito/tazlito.conf" ] ; then
	CONFIG_FILE="/etc/tazlito/tazlito.conf"
fi
# Specific distro config file can be put in a distro tree.
if [ -f "$TOP_DIR/tazlito.conf" ] ; then
	CONFIG_FILE="$TOP_DIR/tazlito.conf"
fi
if [ ! "$CONFIG_FILE" = "" ] ; then
	. $CONFIG_FILE
else
	if [ "$COMMAND" = "gen-config" ] ; then
		continue
	else
		echo "Unable to find any configuration file. Please read the docs"
		echo "or run '`basename $0` gen-config' to get an empty config file."
		exit 0
	fi
fi

# While Tazpkg is not used the default mirror url file does not exist
# and user can't recharge the list of flavors.
if test $(id -u) = 0 ; then
	if [ ! -f "$MIRROR" ]; then
		echo "$DEFAULT_MIRROR" > $MIRROR
	fi
fi

# Set the rootfs and rootcd path with $DISTRO
# configuration variable.
ROOTFS=$DISTRO/rootfs
ROOTCD=$DISTRO/rootcd
FLAVORS_REPOSITORY=/home/slitaz/flavors

#####################
# Tazlito functions #
#####################

# Print the usage.
usage ()
{
	echo -e "\nSliTaz Live Tool - Version: $VERSION\n
\033[1mUsage: \033[0m `basename $0` [command] [list|iso|flavor|compression] [dir|iso]
\033[1mCommands: \033[0m\n
  usage           Print this short usage.
  stats           View Tazlito and distro configuration statistics.
  gen-config      Generate a new configuration file for a distro.
  configure       Configure the main config file or a specific tazlito.conf.
  gen-iso         Generate a new ISO from a distro tree.
  gen-initiso     Generate a new initramfs and ISO from the distro tree.
  list-flavors    List all available package lists on the mirror.
  gen-flavor      Generate a new live-CD description.
  gen-liveflavor  Generate a live-CD description from current system.
  show-flavor     Show live-CD description.
  get-flavor      Get a flavor's list of packages.
  upgrade-flavor  Update package list to the latest available versions.
  extract-flavor  Extract a (*.flavor) flavor into $FLAVORS_REPOSITORY.
  pack-flavor     Pack (and update) a flavor from $FLAVORS_REPOSITORY.
  check-list      Check a distro-packages.list for updates.
  extract-distro  Extract an ISO to a directory and rebuild LiveCD tree.
  gen-distro      Generate a Live distro and ISO from a list of packages.
  clean-distro    Remove all files generated by gen-distro.
  check-distro    Help to check if distro is ready to release.
  writeiso        Use running system to generate a bootable ISO (with /home).
  merge           Merge multiple rootfs into one iso.
  repack          Recompress rootfs into iso with maximum ratio.
  frugal-install  Frugal install in /boot/frugal from a distro or ISO
  emu-iso         Emulate an ISO image with Qemu.
  burn-iso        Burn ISO image to a cdrom using Wodim.\n"
}

# Status function.
status()
{
	local CHECK=$?
	echo -en "\\033[70G[ "
	if [ $CHECK = 0 ]; then
		echo -en "\\033[1;33mOK"
	else
		echo -en "\\033[1;31mFailed"
	fi
	echo -e "\\033[0;39m ]"
	return $CHECK
}

yesorno()
{
	echo -n "$1"
	case "$DEFAULT_ANSWER" in
	Y|y) answer="y";;
	N|n) answer="n";;
	*) read answer;;
	esac
}

field()
{
	grep "^$1" "$2" | sed 's/.*: \([0-9KMG\.]*\).*/\1/'
}

todomsg()
{
	echo -e "\\033[70G[ \\033[1;31mTODO\\033[0;39m ]"
}

# Download a file from this mirror
download_from()
{
	local i
	local mirrors
	mirrors="$1"
	shift
	for i in $mirrors; do
		case "$i" in
		http://*|ftp://*) wget -c $i$@ && break;;
		*) cp $i/$1 . && break;;
		esac
	done
}

# Download a file trying all mirrors
download()
{
	local i
	for i in $(cat $MIRROR $LOCALSTATE/undigest/*/mirror 2> /dev/null); do
		download_from "$i" "$@" && break
	done
}

# Execute hooks provided by some packages
genisohooks()
{
	local here=`pwd`
	for i in $(ls $ROOTFS/etc/tazlito/*.$1 2> /dev/null); do
		cd $ROOTFS
		. $i $ROOTCD
	done
	cd $here
}

cleanup()
{
	if [ -d $TMP_MNT ]; then
		umount $TMP_MNT
		rmdir $TMP_MNT
		rm -f /boot
	fi
}

# Echo the package name if the tazpkg is already installed
installed_package_name()
{
	local tazpkg
	local package
	local VERSION
	local EXTRAVERSION
	tazpkg=$1
	# Try to find package name and version to be able
	# to repack it from installation
	# A dash (-) can exist in name *and* in version
	package=${tazpkg%-*}
	i=$package
	while true; do
		VERSION=""
		eval $(grep -s ^VERSION= $INSTALLED/$i/receipt)
		EXTRAVERSION=""
		eval $(grep -s ^EXTRAVERSION= $INSTALLED/$i/receipt)
		if [ "$i-$VERSION$EXTRAVERSION" = "$tazpkg" ]; then
			echo $i
			break
		fi
		case "$i" in
		*-*);;
		*) break;;
		esac
		i=${i%-*}
	done
}

# Check if user is root.
check_root()
{
	if test $(id -u) != 0 ; then
	   echo -e "\nYou must be root to run `basename $0` with this option."
	   echo -e "Please type 'su' and root password to become super-user.\n"
	   exit 0
	fi
}

# Check for the rootfs tree.
check_rootfs()
{
	if [ ! -d "$ROOTFS/etc" ] ; then
		echo -e "\nUnable to find a distro rootfs...\n"
		exit 0
	fi
}

# Check for the boot dir into the root CD tree.
verify_rootcd()
{
	if [ ! -d "$ROOTCD/boot" ] ; then
		echo -e "\nUnable to find the rootcd boot directory...\n"
		exit 0
	fi
}

create_iso()
{
	genisoimage -R -o $1 -b boot/isolinux/isolinux.bin \
 		-c boot/isolinux/boot.cat -no-emul-boot -boot-load-size 4 \
		-V "$VOLUM_NAME" -p "$PREPARED" -input-charset iso8859-1 \
		-boot-info-table $2
	if [ -x /usr/bin/isohybrid ]; then
		echo -n "Creating hybrid ISO..."
		/usr/bin/isohybrid $1 2> /dev/null
		status
	fi
}

# Generate a new ISO image using isolinux.
gen_livecd_isolinux()
{
	# Some packages may want to alter iso
	genisohooks iso
	if [ ! -f "$ROOTCD/boot/isolinux/isolinux.bin" ]; then
		echo -e "\nUnable to find isolinux binary.\n"
		cleanup
		exit 0
	fi
	# Set date for boot msg.
	if grep -q 'XXXXXXXX' $ROOTCD/boot/isolinux/isolinux.msg; then
		DATE=`date +%Y%m%d`
		echo -n "Setting build date to: $DATE..."
		sed -i s/'XXXXXXXX'/"$DATE"/ $ROOTCD/boot/isolinux/isolinux.msg
		status
	fi
	cd $ROOTCD
	echo -n "Computing md5..."
	find * -type f ! -name md5sum -exec md5sum {} \; > md5sum
	status
	cd $DISTRO
	echo ""
	echo -e "\033[1mGenerating ISO image\033[0m"
	echo "================================================================================"
	create_iso $ISO_NAME.iso $ROOTCD
	echo -n "Creating the ISO md5sum..."
	md5sum $ISO_NAME.iso > $ISO_NAME.md5
	status
	echo "================================================================================"
	# Some packages may want to alter final iso
	genisohooks final
}

lzma_history_bits()
{
	#
	# This genertae ISO who boot with Qemu but give
	# rootfs errors in frugal or liveUSB mode.
	#
	#local n
	#local sz
	#n=20	# 1Mb
	#sz=$(du -sk $1 | cut -f1)
	#while [ $sz -gt 1024 -a $n -lt 28 ]; do
		#n=$(( $n + 1 ))
		#sz=$(( $sz / 2 ))
	#done
	#echo $n
	echo 24
}

lzma_switches()
{
	echo "-d$(lzma_history_bits $1) -mt$(grep ^processor < /proc/cpuinfo | wc -l)"
}

# Pack rootfs
pack_rootfs()
{
	( cd $1 ; find . -print | cpio -o -H newc ) | \
	if [ "$COMPRESSION" = "none" ]; then
		echo "Generating uncompressed initramfs... "
		cat > $2
	elif [ -x /usr/bin/lzma -a "$COMPRESSION" != "gzip" ]; then
		echo -n "Generating lzma'ed initramfs... "
		lzma e -si -so $(lzma_switches $1) > $2
	else
		echo "Generating gziped initramfs... "
		gzip -9 > $2
	fi
	echo 1 > /tmp/rootfs
}

# Compression functions for writeiso.
write_initramfs()
{
	if [ "$COMPRESSION" = "lzma" ]; then
		echo -n "Creating rootfs.gz with lzma compression... "
		cat /tmp/list | cpio -o -H newc | lzma e -si -so > /rootfs.gz
	elif [ "$COMPRESSION" = "gzip" ]; then
		echo "Creating rootfs.gz with gzip compression... "
		cat /tmp/list | cpio -o -H newc | gzip -9 > /rootfs.gz
	else
		echo "Creating rootfs.gz without compression... "
		cat /tmp/list | cpio -o -H newc > /rootfs.gz
	fi
	echo 1 > /tmp/rootfs
}

# Generate a new initramfs from the root filesystem.
gen_initramfs()
{
	# Just in case CTRL+c
	rm -f $DISTRO/gen
	# Some packages may want to alter rootfs
	genisohooks rootfs
	cd $1
	echo ""

        # Link duplicate files
        find . -type f -size +0c -exec stat -c '%s-%a-%u-%g %i %h %n' {} \; | \
           sort | ( save=0; old_attr=""; old_inode=""; old_link=""; old_file=""
           while read attr inode link file; do
               if [ "$attr" = "$old_attr" -a "$inode" != "$old_inode" ]; then
                   if cmp "$file" "$old_file" >/dev/null; then
                       rm -f "$file"
                       ln "$old_file" "$file"
                       inode="$old_inode"
                       [ "$link" = "1" ] && save="$(expr $save + ${attr%%-*})"
                   fi
               fi
               old_attr="$attr" ; old_inode="$inode" ; old_file="$file"
           done
           echo "$save bytes saved in duplicate files."
        )

	# Use lzma if installed. Display rootfs size in realtime.
	rm -f /tmp/rootfs
	pack_rootfs . $DISTRO/$(basename $1).gz &
	sleep 2
	echo -en "\nFilesystem size:"
	while [ ! -f /tmp/rootfs ]
	do
		sleep 1
		echo -en "\\033[18G`du -sh $DISTRO/rootfs.gz | awk '{print $1}'`    "
	done
	echo -e "\n"
	cd $DISTRO
	mv $(basename $1).gz $ROOTCD/boot
}

distro_sizes()
{
	echo "Build date      : `date +%Y%m%d\ \at\ \%H:%M:%S`"
	echo "Packages        : `ls -1 $ROOTFS*$INSTALLED/*/receipt | wc -l`"
	echo "Rootfs size     : `du -csh $ROOTFS*/ | awk '{ s=$1 } END { print s }'`"
	echo "Initramfs size  : `du -csh $ROOTCD/boot/rootfs*.gz | awk '{ s=$1 } END { print s }'`"
	echo "ISO image size  : `du -sh $ISO_NAME.iso | awk '{ print $1 }'`"
	echo "================================================================================"
	echo "Image is ready: $ISO_NAME.iso"
	echo ""
}

# Print ISO and rootfs size.
distro_stats()
{
	echo ""
	echo -e "\033[1mDistro statistics\033[0m ($DISTRO)"
	echo "================================================================================"
	distro_sizes
}

# Create an empty configuration file.
empty_config_file()
{
	cat >> tazlito.conf << "EOF"
# tazlito.conf: Tazlito (SliTaz Live Tool)
# configuration file.
#

# Name of the ISO image to generate.
ISO_NAME=""

# ISO image volume name.
VOLUM_NAME="SliTaz"

# Name of the preparer.
PREPARED="$USER"

# Path to the packages repository and the packages.list.
PACKAGES_REPOSITORY=""

# Path to the distro tree to gen-distro from a
# list of packages.
DISTRO=""

# Path to the directory containing additional files
# to copy into the rootfs and rootcd of the LiveCD.
ADDFILES="$DISTRO/addfiles"

# Default answer for binary question (Y or N)
DEFAULT_ANSWER="ASK"

# Compression utility (lzma, gzip or none)
COMPRESSION="lzma"
EOF
}

# extract rootfs.gz somewhere
extract_rootfs()
{
	(zcat $1 || unlzma -c $1 || cat $1) 2>/dev/null | \
		(cd $2; cpio -idm > /dev/null)
}

# Remove duplicate files
mergefs()
{
	echo -n "Merge $(basename $1) ($(du -hs $1 | awk '{ print $1}')) into "
	echo -n       "$(basename $2) ($(du -hs $2 | awk '{ print $1}'))"
	# merge symlinks files and devices
	( cd $1; find ) | while read file; do
		if [ -L $1/$file ]; then
			[ -L $2/$file ] &&
			[ "$(readlink $1/$file)" == "$(readlink $2/$file)" ] &&
			rm -f $2/$file
		elif [ -f $1/$file ]; then
			[ -f $2/$file ] &&
			cmp $1/$file $2/$file > /dev/null 2>&1 && rm -f $2/$file
			[ -f $2/$file ] && 
			[ "$(basename $file)" == "volatile.cpio.gz" ] &&
			[ "$(dirname $(dirname $file))" == \
			  "./var/lib/tazpkg/installed" ] && rm -f $2/$file
		elif [ -b $1/$file ]; then
			[ -b $2/$file ] && rm -f $2/$file
		elif [ -c $1/$file ]; then
			[ -c $2/$file ] && rm -f $2/$file
		fi
	done
	
	# cleanup directories
	( cd $1; find ) | while read file; do
		if [ -d $1/$file ]; then
			[ -d $2/$file ] && rmdir $2/$file 2> /dev/null
		fi
	done
	true
	status
}

cleanup_merge()
{
	rm -rf $TMP_DIR
	exit 1
}

human2cent()
{
case "$1" in
*k) echo $1 | sed 's/\(.*\).\(.\)k/\1\2/';;
*M) echo $(( $(echo $1 | sed 's/\(.*\).\(.\)M/\1\2/') * 1024));;
*G) echo $(( $(echo $1 | sed 's/\(.*\).\(.\)G/\1\2/') * 1024 * 1024));;
esac
}

cent2human()
{
if [ $1 -lt 10000 ]; then
  echo "$(($1 / 10)).$(($1 % 10))k"
elif [ $1 -lt 10000000 ]; then
  echo "$(($1 / 10240)).$(( ($1/1024) % 10))M"
else
  echo "$(($1 / 10485760)).$(( ($1/1048576) % 10))G"
fi
}

get_size()
{
cat /var/lib/tazpkg/packages.list $TMP_DIR/packages.list 2>/dev/null | awk "{ \
if (/^$(echo $1 | sed 's/[$+.\]/\\&/g')$/) get=1; \
if (/installed/ && get == 1) { print ; get++ } \
}
END { if (get < 2) print \" 0.0k  (0.0k installed)\" }" | \
sed 's/ *\(.*\) .\(.*\) installed./\1 \2/' | while read packed unpacked; do
  echo "$(human2cent $packed) $(human2cent $unpacked)"
done
}

# Display package list with version, set packed_size and unpacked_size
get_pkglist()
{
packed_size=0; unpacked_size=0
grep -v ^#  $FLAVORS_REPOSITORY/$1/packages.list > $TMP_DIR/flavor.pkg
while read pkg; do
	set -- $(get_size $pkg)
	packed_size=$(( $packed_size + $1 ))
	unpacked_size=$(( $unpacked_size + $2 ))
	for i in $(grep -hs ^$pkg /var/lib/tazpkg/packages.list \
				  $TMP_DIR/packages.list); do
		echo $i
		break
	done
done < $TMP_DIR/flavor.pkg
rm -f $TMP_DIR/flavor.pkg
}

# Update isolinux config files for multiple rootfs
update_bootconfig()	
{
	echo -n "Updating boot config files..."
	grep -l 'include common' $1/*.cfg | \
	while read file ; do
			awk -v n=$(echo $2 | awk '{ print NF/2 }') '{
if (/label/) label=$0;
else if (/kernel/) kernel=$0;
else if (/append/) {
	i=index($0,"rootfs.gz");
	append=substr($0,i+9);
}
else if (/include/) {
	for (i = 1; i <= n; i++) {
		print label i
		print kernel;
		initrd="initrd=/boot/rootfs" n ".gz"
		for (j = n - 1; j >= i; j--) {
			initrd=initrd ",/boot/rootfs" j ".gz";
		}
		printf "\tappend %s%s\n",initrd,append;
		print "";
	}
	print;
}
else print;
}' < $file > $file.$$
			mv -f $file.$$ $file
	done
	cat >> $1/common.cfg <<EOT

label slitaz
	kernel /boot/isolinux/ifmem.c32
	append$(echo $2 | awk '{
  for (i=1; i<=NF; i++)
     if (i % 2 == 0) printf " slitaz%d",i/2
     else printf " %s",$i
}') noram

label noram
	config noram.cfg

EOT
	cat > $1/noram.cfg <<EOT
display isolinux.msg
say Not enough RAM to boot slitaz.
default reboot
label reboot
	com32 reboot.c32

implicit 0
prompt 1
timeout 80
F1 help.txt
F2 options.txt
F3 isolinux.msg
F4 display.txt
F5 enhelp.txt
F6 enopts.txt
EOT
	status
}

####################
# Tazlito commands #
####################

case "$COMMAND" in
	stats)
		# Tazlito general statistics from the config file.
		#
		echo ""
		echo -e "\033[1mTazlito statistics\033[0m
===============================================================================
Config file         : $CONFIG_FILE
ISO name            : $ISO_NAME.iso
Volume name         : $VOLUM_NAME
Prepared            : $PREPARED
Packages repository : $PACKAGES_REPOSITORY
Distro directory    : $DISTRO"
		if [ ! "$ADDFILES" = "" ] ; then
			echo -e "Additional files    : $ADDFILES"
		fi
		echo "================================================================================"
		echo ""
	    ;;
	list-addfiles)
		# Simple list of additonal files in the rootfs
		echo ""
		cd $ADDFILES
		find rootfs -type f
		echo "" ;;
	gen-config)
		# Generate a new config file in the current dir or the specified
		# directory by $2.
		#
		if [ -n "$2" ] ; then
			mkdir -p $2 && cd $2
		fi
		echo -n "Generating empty tazlito.conf..."
		empty_config_file
		status
		echo ""
		if [ -f "tazlito.conf" ] ; then
			echo "Configuration file is ready to edit."
			echo "File location : `pwd`/tazlito.conf"
			echo ""
		fi
		;;
	configure)
		# Configure a tazlito.conf config file. Start by getting
		# a empty config file and sed it.
		#
		if [ -f "tazlito.conf" ] ; then
			rm tazlito.conf
		else
			if test $(id -u) = 0 ; then
				cd /etc
			else
				echo "You must be root to configure the main config file or in"
				echo "the same directory of the file you want to configure."
				exit 0
			fi
		fi
		empty_config_file
		echo""
		echo -e "\033[1mConfiguring :\033[0m `pwd`/tazlito.conf"
		echo "================================================================================"
		# ISO name.
		echo -n "ISO name            : " ; read answer
		sed -i s#'ISO_NAME=\"\"'#"ISO_NAME=\"$answer\""# tazlito.conf
		# Volume name.
		echo -n "Volume name         : " ; read answer
		sed -i s/'VOLUM_NAME=\"SliTaz\"'/"VOLUM_NAME=\"$answer\""/ tazlito.conf
		# Packages repository.
		echo -n "Packages repository : " ; read answer
		sed -i s#'PACKAGES_REPOSITORY=\"\"'#"PACKAGES_REPOSITORY=\"$answer\""# tazlito.conf
		# Distro path.
		echo -n "Distro path         : " ; read answer
		sed -i s#'DISTRO=\"\"'#"DISTRO=\"$answer\""# tazlito.conf
		echo "================================================================================"
		echo "Config file is ready to use."
		echo "You can now extract an ISO or generate a distro."
		echo ""
		;;
	gen-iso)
		# Simply generate a new iso.
		#
		check_root
		verify_rootcd
		gen_livecd_isolinux
		distro_stats
		;;
	gen-initiso)
		# Simply generate a new initramfs with a new iso.
		#
		check_root
		verify_rootcd
		gen_initramfs $ROOTFS
		gen_livecd_isolinux
		distro_stats
		;;
	extract-distro)
		# Extract an ISO image to a directory and rebuild the LiveCD tree.
		#
		check_root
		ISO_IMAGE=$2
		if [ -z "$ISO_IMAGE" ] ; then
			echo -e "\nPlease specify the path to the ISO image."
			echo -e "Example : `basename $0` image.iso /path/target\n"
			exit 0
		fi
		# Set the distro path by checking for $3 on cmdline.
		if [ -n "$3" ] ; then
			TARGET=$3
		else
			TARGET=$DISTRO
		fi
		# Exit if existing distro is found.
		if [ -d "$TARGET/rootfs" ] ; then
			echo -e "\nA rootfs exists in : $TARGET"
			echo -e "Please clean the distro tree or change directory path.\n"
			exit 0
		fi
		echo ""
		echo -e "\033[1mTazlito extracting :\033[0m `basename $ISO_IMAGE`"
		echo "================================================================================"
		# Start to mount the ISO.
		echo ""
		echo "Mounting ISO image..."
		mkdir -p $TMP_DIR
		# Get ISO file size.
		isosize=`du -sh $ISO_IMAGE | cut -f1`
		mount -o loop $ISO_IMAGE $TMP_DIR
		sleep 2
		# Prepare target dir, copy the kernel and the rootfs.
		mkdir -p $TARGET/rootfs
		mkdir -p $TARGET/rootcd/boot
		echo -n "Copying the Linux kernel..."
		if cp $TMP_DIR/boot/vmlinuz* $TARGET/rootcd/boot 2> /dev/null; then
			ln $TARGET/rootcd/boot/vmlinuz* $TARGET/rootcd/boot/bzImage
		else
			cp $TMP_DIR/boot/bzImage $TARGET/rootcd/boot
		fi
		status
		echo -n "Copying isolinux files..."
		cp -a $TMP_DIR/boot/isolinux $TARGET/rootcd/boot
		for i in $(ls $TMP_DIR); do
			[ "$i" = "boot" ] && continue
			cp -a $TMP_DIR/$i $TARGET/rootcd
		done
		status
		if [ -d $TMP_DIR/boot/syslinux ]; then
			echo -n "Copying syslinux files..."
			cp -a $TMP_DIR/boot/syslinux $TARGET/rootcd/boot
			status
		fi
		if [ -d $TMP_DIR/boot/extlinux ]; then
			echo -n "Copying extlinux files..."
			cp -a $TMP_DIR/boot/extlinux $TARGET/rootcd/boot
			status
		fi
		if [ -d $TMP_DIR/boot/grub ]; then
			echo -n "Copying GRUB files..."
			cp -a $TMP_DIR/boot/grub $TARGET/rootcd/boot
			status
		fi
		
		echo -n "Copying the rootfs..."
		cp $TMP_DIR/boot/rootfs.?z $TARGET/rootcd/boot
		status
		# Extract initramfs.
		cd $TARGET/rootfs
		echo -n "Extracting the rootfs... "
		extract_rootfs ../rootcd/boot/rootfs.gz $TARGET/rootfs
		# unpack /usr
		for i in etc/tazlito/*.extract; do
			[ -f "$i" ] && . $i ../rootcd
		done
		# Umount and remove temp directory and cd to $TARGET to get stats.
		umount $TMP_DIR && rm -rf $TMP_DIR
		cd ..
		echo ""
		echo "================================================================================"
		echo "Extracted       : `basename $ISO_IMAGE` ($isosize)"
		echo "Distro tree     : `pwd`"
		echo "Rootfs size     : `du -sh rootfs`"
		echo "Rootcd size     : `du -sh rootcd`"
		echo "================================================================================"
		echo ""
		;;
	list-flavors)
		# Show available flavors.
		if [ ! -s /etc/tazlito/flavors.list -o "$2" == "--recharge" ]; then
			download flavors.list -O - > /etc/tazlito/flavors.list
		fi
		echo ""
		echo -e "\033[1mList of flavors\033[0m"
		echo "================================================================================"
		cat /etc/tazlito/flavors.list
		echo ""
		;;
	show-flavor)
		# Show flavor description.
		FLAVOR=${2%.flavor}
		if [ ! -f "$FLAVOR.flavor" ]; then
			echo "File $FLAVOR.flavor not found."
			exit 1
		fi
		mkdir $TMP_DIR
		zcat $FLAVOR.flavor | ( cd $TMP_DIR; cpio -i 2> /dev/null)
		if [ "$3" = "--brief" ]; then
			if [ "$4" != "--noheader" ]; then
				echo "Name              ISO   Rootfs  Description"
				echo "================================================================================"
			fi
			printf "%-16.16s %6.6s %6.6s %s\n" "$FLAVOR" \
				"$(field ISO $TMP_DIR/$FLAVOR.desc)" \
				"$(field 'Rootfs size' $TMP_DIR/$FLAVOR.desc)" \
				"$(grep ^Description $TMP_DIR/$FLAVOR.desc | cut -d: -f2)"
		else
			echo "================================================================================"
			cat $TMP_DIR/$FLAVOR.desc
		fi
		rm -Rf $TMP_DIR
		;;
	gen-liveflavor)
		# Generate a new flavor form the live system.
		FLAVOR=${2%.flavor}
		DESC=""
		case "$FLAVOR" in
		'')	echo -n "Flavor name : "
			read FLAVOR
			[ -z "$FLAVOR" ] && exit 1;;
		-?|-h*|--help) echo -e "

SliTaz Live Tool - Version: $VERSION
\033[1mUsage: \033[0m `basename $0` gen-liveflavor flavor-name [flavor-patch-file]
\033[1mflavor-patch-file format: \033[0m
code	data
+	package to add
-	package to remove
!	non-free package to add
?	display message
@	flavor description

\033[1mExample: \033[0m
@	Developer tools for slitaz maintainers
+	slitaz-toolchain
+	mercurial
"
			exit 1;;
		esac
		mv /etc/tazlito/distro-packages.list \
		   /etc/tazlito/distro-packages.list.$$ 2> /dev/null
		rm -f distro-packages.list non-free.list 2> /dev/null
		tazpkg recharge
		[ -n "$3" ] && while read action pkg; do
			case "$action" in
			+)	yes | tazpkg get-install $pkg;;
			-)	yes | tazpkg remove $pkg;;
			!)	echo $pkg >> non-free.list;;
			@)	DESC="$pkg";;
			\?)	echo -en "$pkg"; read action;;
			esac
		done < $3
		yes '' | tazlito gen-distro
		echo "$DESC" | tazlito gen-flavor "$FLAVOR"
		mv /etc/tazlito/distro-packages.list.$$ \
		   /etc/tazlito/distro-packages.list 2> /dev/null
		;;
	gen-flavor)
		# Generate a new flavor from the last iso image generated.
		FLAVOR=${2%.flavor}
		echo ""
		echo -e "\033[1mFlavor generation\033[0m"
		echo "================================================================================"
		if [ -z "$FLAVOR" ]; then
			echo -n "Flavor name : "
			read FLAVOR
			[ -z "$FLAVOR" ] && exit 1
		fi
		check_rootfs
		FILES="$FLAVOR.pkglist"
		echo -n "Creating file $FLAVOR.flavor..."
		for i in rootcd rootfs; do
			if [ -d "$ADDFILES/$i" ] ; then
				FILES="$FILES\n$FLAVOR.$i"
				( cd "$ADDFILES/$i"; find . | \
				  cpio -o -H newc 2> /dev/null | gzip -9 ) > $FLAVOR.$i
			fi
		done
		status
		answer=`grep -s ^Description $FLAVOR.desc`
		answer=${answer#Description     : }
		if [ -z "$answer" ]; then
			echo -n "Description : "
			read answer
		fi
		echo -n "Compressing flavor $FLAVOR..."
		echo "Flavor          : $FLAVOR" > $FLAVOR.desc
		echo "Description     : $answer" >> $FLAVOR.desc
		( cd $DISTRO; distro_sizes) >> $FLAVOR.desc
		\rm -f $FLAVOR.pkglist $FLAVOR.nonfree 2> /dev/null
		for i in $(ls $ROOTFS$INSTALLED); do
			eval $(grep ^VERSION= $ROOTFS$INSTALLED/$i/receipt)
			EXTRAVERSION=""
			eval $(grep ^EXTRAVERSION= $ROOTFS$INSTALLED/$i/receipt)
			eval $(grep ^CATEGORY= $ROOTFS$INSTALLED/$i/receipt)
			if [ "$CATEGORY" = "non-free" -a "${i%%-*}" != "get" ]
			then
				echo "$i" >> $FLAVOR.nonfree
			else
				echo "$i-$VERSION$EXTRAVERSION" >> $FLAVOR.pkglist
			fi
		done
		[ -s $FLAVOR.nonfree ] && $FILES="$FILES\n$FLAVOR.nonfree"
		for i in $LOCALSTATE/undigest/*/mirror ; do
			[ -s $i ] && cat $i >> $FLAVOR.mirrors
		done
		[ -s $FLAVOR.mirrors ] && $FILES="$FILES\n$FLAVOR.mirrors"
		echo -e "$FLAVOR.desc\n$FILES" | cpio -o -H newc 2>/dev/null | \
			gzip -9 > $FLAVOR.flavor
		rm `echo -e $FILES`
		status
		echo "================================================================================"
		echo "Flavor size : `du -sh $FLAVOR.flavor`"
		echo ""
		;;
	upgrade-flavor)
		# Update package list to the lastest versions available.
		FLAVOR=${2%.flavor}
		if [ -f $FLAVOR.flavor ] || download $FLAVOR.flavor; then
			mkdir $TMP_DIR
			zcat $FLAVOR.flavor | ( cd $TMP_DIR; cpio -i >/dev/null )
			echo -n "Updating $FLAVOR package list..."
			[ -s /var/lib/tazpkg/packages.list ] || tazpkg recharge
			packed_size=0; unpacked_size=0
			while read org; do
				i=0
				pkg=$org
				while ! grep -q ^$pkg$ /var/lib/tazpkg/packages.txt; do
					pkg=${pkg%-*}
					i=$(($i + 1))
					[ $i -gt 5 ] && break;
				done
				set -- $(get_size $pkg)
				packed_size=$(( $packed_size + $1 ))
				unpacked_size=$(( $unpacked_size + $2 ))
				for i in $(grep ^$pkg /var/lib/tazpkg/packages.list); do
					echo $i
					break
				done
			done <  $TMP_DIR/$FLAVOR.pkglist \
			     > $TMP_DIR/$FLAVOR.pkglist.$$
			mv -f $TMP_DIR/$FLAVOR.pkglist.$$ $TMP_DIR/$FLAVOR.pkglist
			if [ -s $TMP_DIR/$FLAVOR.rootfs ]; then
				packed_size=$(($packed_size \
					+ $(cat $TMP_DIR/$FLAVOR.rootfs | wc -c ) / 100 ))
				unpacked_size=$(($unpacked_size \
					+ $(zcat $TMP_DIR/$FLAVOR.rootfs | wc -c ) / 100 ))
			fi
			# Estimate lzma
			packed_size=$(($packed_size * 2 / 3))
			iso_size=$(( $packed_size + 26000 ))
			if [ -s $TMP_DIR/$FLAVOR.rootcd ]; then
				iso_size=$(($iso_size \
					+ $(zcat $TMP_DIR/$FLAVOR.rootcd | wc -c ) / 100 ))
			fi
			sed -i -e '/Image is ready/d' \
			       -e "s/Rootfs size\( *:\) \(.*\)/Rootfs size\1 $(cent2human $unpacked_size)  (estimated)/" \
			       -e "s/Initramfs size\( *:\) \(.*\)/Initramfs size\1 $(cent2human $packed_size)  (estimated)/" \
			       -e "s/ISO image size\( *:\) \(.*\)/ISO image size\1 $(cent2human $iso_size)  (estimated)/" \
			       -e "s/date\( *:\) \(.*\)/date\1 $(date +%Y%m%d\ \at\ \%H:%M:%S)/" \
					$TMP_DIR/$FLAVOR.desc
			( cd $TMP_DIR ; ls | cpio -o -H newc ) | gzip -9 > \
				$FLAVOR.flavor
			status
			rm -Rf $TMP_DIR
		fi
		;;
	extract-flavor)
		# Extract a flavor into $FLAVORS_REPOSITORY.
		FLAVOR=${2%.flavor}
		if [ -f $FLAVOR.flavor ] || download $FLAVOR.flavor; then
			mkdir $TMP_DIR
			zcat $FLAVOR.flavor | ( cd $TMP_DIR; cpio -i >/dev/null )
			echo -n "Extracting $FLAVOR..."
			rm -rf $FLAVORS_REPOSITORY/$FLAVOR 2> /dev/null
			mkdir -p $FLAVORS_REPOSITORY/$FLAVOR
			echo "FLAVOR=\"$FLAVOR\"" > $FLAVORS_REPOSITORY/$FLAVOR/receipt
			grep ^Description $TMP_DIR/$FLAVOR.desc | \
				sed 's/.*: \(.*\)$/SHORT_DESC="\1"/' >> \
				$FLAVORS_REPOSITORY/$FLAVOR/receipt
			grep -q '^Rootfs list' $TMP_DIR/$FLAVOR.desc && \
			grep '^Rootfs list' $TMP_DIR/$FLAVOR.desc | \
				sed 's/.*: \(.*\)$/ROOTFS_SELECTION="\1"/' >> \
				$FLAVORS_REPOSITORY/$FLAVOR/receipt
			grep '^Rootfs size' $TMP_DIR/$FLAVOR.desc | \
				sed 's/.*: \(.*\)$/ROOTFS_SIZE="\1"/' >> \
				$FLAVORS_REPOSITORY/$FLAVOR/receipt
			grep ^Initramfs $TMP_DIR/$FLAVOR.desc | \
				sed 's/.*: \(.*\)$/INITRAMFS_SIZE="\1"/' >> \
				$FLAVORS_REPOSITORY/$FLAVOR/receipt
			grep ^ISO $TMP_DIR/$FLAVOR.desc | \
				sed 's/.*: \(.*\)$/ISO_SIZE="\1"/' >> \
				$FLAVORS_REPOSITORY/$FLAVOR/receipt
			for i in rootcd rootfs; do
				[ -f $TMP_DIR/$FLAVOR.$i ] || continue
				mkdir $FLAVORS_REPOSITORY/$FLAVOR/$i
				zcat $TMP_DIR/$FLAVOR.$i | \
				  (cd $FLAVORS_REPOSITORY/$FLAVOR/$i; \
				   cpio -idm > /dev/null)
			done
			[ -s $TMP_DIR/$FLAVOR.mirrors ] &&
				cp $TMP_DIR/$FLAVOR.mirrors \
					$FLAVORS_REPOSITORY/$FLAVOR/mirrors
			[ -s /var/lib/tazpkg/packages.list ] || tazpkg recharge
			while read org; do
				i=0
				pkg=$org
				while ! grep -q ^$pkg$ /var/lib/tazpkg/packages.txt; do
					pkg=${pkg%-*}
					i=$(($i + 1))
					[ $i -gt 5 ] && break;
				done
				echo $pkg
			done <  $TMP_DIR/$FLAVOR.pkglist \
			     > $FLAVORS_REPOSITORY/$FLAVOR/packages.list
			status
			rm -Rf $TMP_DIR
		fi
		;;
	pack-flavor)
		# Create a flavor from $FLAVORS_REPOSITORY.
		FLAVOR=${2%.flavor}
		if [ -s $FLAVORS_REPOSITORY/$FLAVOR/receipt ]; then
			mkdir $TMP_DIR
			echo -n "Creating flavor $FLAVOR..."
			[ -s /var/lib/tazpkg/packages.list ] || tazpkg recharge
			if [ -s $FLAVORS_REPOSITORY/$FLAVOR/mirrors ]; then
				cp $FLAVORS_REPOSITORY/$FLAVOR/mirrors \
					$TMP_DIR/$FLAVOR.mirrors
				for i in $(cat $TMP_DIR/$FLAVOR.mirrors); do
					wget -O - $i/packages.list >> $TMP_DIR/packages.list
				done
			fi
			[ -s $FLAVORS_REPOSITORY/$FLAVOR/packages.list ] &&
			get_pkglist $FLAVOR > $TMP_DIR/$FLAVOR.pkglist
			if grep -q ^ROOTFS_SELECTION \
				$FLAVORS_REPOSITORY/$FLAVOR/receipt; then
				. $FLAVORS_REPOSITORY/$FLAVOR/receipt
				set -- $ROOTFS_SELECTION
				[ -n "$FRUGAL_RAM" ] || FRUGAL_RAM=$1
				[ -f $FLAVORS_REPOSITORY/$2/packages.list ] ||
					tazlito extract-flavor $2
				get_pkglist $2 > $TMP_DIR/$FLAVOR.pkglist
			fi
			for i in rootcd rootfs; do
				[ -d $FLAVORS_REPOSITORY/$FLAVOR/$i ] || \
					continue
				( cd $FLAVORS_REPOSITORY/$FLAVOR/$i ; find . | \
				cpio -o -H newc 2> /dev/null ) | \
				gzip -9 >$TMP_DIR/$FLAVOR.$i
			done
			if [ -s $TMP_DIR/$FLAVOR.rootfs ]; then
				packed_size=$(($packed_size \
					+ $(cat $TMP_DIR/$FLAVOR.rootfs | wc -c ) / 100 ))
				unpacked_size=$(($unpacked_size \
					+ $(zcat $TMP_DIR/$FLAVOR.rootfs | wc -c ) / 100 ))
			fi
			# Estimate lzma
			packed_size=$(($packed_size * 2 / 3))
			iso_size=$(( $packed_size + 26000 ))
			if [ -s $TMP_DIR/$FLAVOR.rootcd ]; then
				iso_size=$(($iso_size \
					+ $(zcat $TMP_DIR/$FLAVOR.rootcd | wc -c ) / 100 ))
			fi
			VERSION=""
			MAINTAINER=""
			ROOTFS_SELECTION=""
			ROOTFS_SIZE="$(cent2human $unpacked_size) (estimated)"
			INITRAMFS_SIZE="$(cent2human $packed_size) (estimated)"
			ISO_SIZE="$(cent2human $iso_size) (estimated)"
			. $FLAVORS_REPOSITORY/$FLAVOR/receipt
			cat > $TMP_DIR/$FLAVOR.desc <<EOT
Flavor          : $FLAVOR
Description     : $SHORT_DESC
EOT
			[ -n "$VERSION" ] && cat >> $TMP_DIR/$FLAVOR.desc <<EOT
Version         : $VERSION
EOT
			[ -n "$MAINTAINER" ] && cat >> $TMP_DIR/$FLAVOR.desc <<EOT
Maintainer      : $MAINTAINER
EOT
			[ -n "$FRUGAL_RAM" ] && cat >> $TMP_DIR/$FLAVOR.desc <<EOT
LiveCD RAM size : $FRUGAL_RAM
EOT
			[ -n "$ROOTFS_SELECTION" ] && cat >> $TMP_DIR/$FLAVOR.desc <<EOT
Rootfs list     : $ROOTFS_SELECTION
EOT
			cat >> $TMP_DIR/$FLAVOR.desc <<EOT
Build date      : $(date +%Y%m%d\ \at\ \%H:%M:%S)
Packages        : $(grep -v ^# $TMP_DIR/$FLAVOR.pkglist | wc -l)
Rootfs size     : $ROOTFS_SIZE
Initramfs size  : $INITRAMFS_SIZE
ISO image size  : $ISO_SIZE
================================================================================

EOT
			rm -f $TMP_DIR/packages.list
			( cd $TMP_DIR ; ls | cpio -o -H newc 2> /dev/null) | \
				gzip -9 > $FLAVOR.flavor
			status
			rm -Rf $TMP_DIR
		else
			echo "No $FLAVOR flavor in $FLAVORS_REPOSITORY."
		fi
		;;
	get-flavor)
		# Get a flavor's files and prepare for gen-distro.
		FLAVOR=${2%.flavor}
		echo ""
		if [ -f $FLAVOR.flavor ] || download $FLAVOR.flavor; then
			echo -n "Cleaning $DISTRO..."
			rm -R $DISTRO 2> /dev/null
			mkdir -p $DISTRO
			status
			mkdir $TMP_DIR
			echo -n "Extracting flavor $FLAVOR.flavor... "
			zcat $FLAVOR.flavor | ( cd $TMP_DIR; cpio -i 2>/dev/null )
			echo -n "Creating distro-packages.list..."
			mv $TMP_DIR/$FLAVOR.nonfree non-free.list 2> /dev/null
			mv $TMP_DIR/$FLAVOR.pkglist distro-packages.list
			status
			for i in rootcd rootfs; do
				if [ -f $TMP_DIR/$FLAVOR.$i ]; then
					echo -n "Adding $i... "
					mkdir -p "$ADDFILES/$i"
					zcat $TMP_DIR/$FLAVOR.$i | \
						( cd "$ADDFILES/$i"; cpio -id 2> /dev/null)
				fi
			done
			if [ -s $TMP_DIR/$FLAVOR.mirrors ]; then
				n=""
				while read line; do
					mkdir -p $LOCALSTATE/undigest/$FLAVOR$n
					echo "$line" > $LOCALSTATE/undigest/$FLAVOR$n/mirror
					n=$(( $n + 1 ))
				done < $TMP_DIR/$FLAVOR.mirrors
				tazpkg recharge
			fi
			rm -f /etc/tazlito/rootfs.list
			grep -q '^Rootfs list' $TMP_DIR/$FLAVOR.desc &&
				grep '^Rootfs list' $TMP_DIR/$FLAVOR.desc | \
				sed 's/.*: \(.*\)$/\1/' > /etc/tazlito/rootfs.list
			echo -n "Updating tazlito.conf..."
			[ -f tazlito.conf ] || cp /etc/tazlito/tazlito.conf .
			cat tazlito.conf | grep -v "^#VOLUM_NAME" | \
			sed "s/^VOLUM_NA/VOLUM_NAME=\"SliTaz $FLAVOR\"\\n#VOLUM_NA/" \
				> tazlito.conf.$$ && mv tazlito.conf.$$ tazlito.conf
			sed -i "s/ISO_NAME=.*/ISO_NAME=\"slitaz-$FLAVOR\"/" tazlito.conf
			status
			rm -Rf $TMP_DIR
		fi
		echo ""
		;;
	check-list)
		# Use current packages list in $PWD by default.
		DISTRO_PKGS_LIST=distro-packages.list
		[ -d "$2" ] && DISTRO_PKGS_LIST=$2/distro-packages.list
		[ -f "$2" ] && DISTRO_PKGS_LIST=$2
		[ ! -f $DISTRO_PKGS_LIST ] && echo "No packages list found." && exit 0
		echo ""
		echo -e "\033[1mLiveCD packages list check\033[0m"
		echo "================================================================================"
		for pkg in `cat $DISTRO_PKGS_LIST`
		do
			if ! grep -q "$pkg" /var/lib/tazpkg/packages.list; then
				echo "Update: $pkg"
				up=$(($up + 1))
			fi
		done
		[ -z $up ] && echo -e "List is up-to-date\n" && exit 0
		echo "================================================================================"
		echo -e "Updates: $up\n" ;;
	gen-distro)
		# Generate a live distro tree with a set of packages.
		#
		check_root
		
		# Check if a package list was specified on cmdline.
		LIST_NAME="distro-packages.list"
		CDROM=""
		while [ -n "$2" ]; do
			case "$2" in
			--iso=*)
				CDROM="-o loop ${2#--iso=}"
				;;
			--cdrom)
				CDROM="/dev/cdrom"
				;;
			--force)
				DELETE_ROOTFS="true"
				;;
			*)	if [ ! -f "$2" ] ; then
					echo -e "\nUnable to find the specified packages list."
					echo -e "List name : $2\n"
					exit 1
				fi
				LIST_NAME=$2
				;;
			esac
			shift
		done
		 
		if [ -d $ROOTFS ] ; then
			# Delete $ROOTFS if --force is set on command line
			if [ ! -z $DELETE_ROOTFS ]; then
				rm -rf $ROOTFS
				unset $DELETE_ROOTFS
			else
				echo -e "\nA rootfs exists in : $DISTRO"
				echo -e "Please clean the distro tree or change directory path.\n"
				exit 0
			fi
		fi
		if [ ! -f "$LIST_NAME" -a -d $INSTALLED ] ; then
		# Build list with installed packages
			for i in $(ls $INSTALLED); do
				eval $(grep ^VERSION= $INSTALLED/$i/receipt)
				EXTRAVERSION=""
				eval $(grep ^EXTRAVERSION= $INSTALLED/$i/receipt)
				echo "$i-$VERSION$EXTRAVERSION" >> $LIST_NAME
			done
		fi
		# Exit if no list name.
		if [ ! -f "$LIST_NAME" ]; then
			echo -e "\nNo packages list found or specified. Please read the docs.\n"
			exit 0
		fi
		# Start generation.
		echo ""
		echo -e "\033[1mTazlito generating a distro\033[0m"
		echo "================================================================================"
		# Misc checks
		[ -n "$PACKAGES_REPOSITORY" ] || PACKAGES_REPOSITORY="."
		[ -d $PACKAGES_REPOSITORY ] || mkdir -p $PACKAGES_REPOSITORY
		# Get the list of packages using cat for a file list.
		LIST=`cat $LIST_NAME`
		# Verify if all packages in list are present in $PACKAGES_REPOSITORY.
		REPACK=""
		DOWNLOAD=""
		for pkg in $LIST
		do
			[ "$pkg" = "" ] && continue
			pkg=${pkg%.tazpkg}
			[ -f $PACKAGES_REPOSITORY/$pkg.tazpkg ] && continue
			PACKAGE=$(installed_package_name $pkg)
			[ -n "$PACKAGE" -a "$REPACK" = "y" ] && continue
			[ -z "$PACKAGE" -a -n "$DOWNLOAD" ] && continue
			echo -e "\nUnable to find $pkg in the repository."
			echo -e "Path : $PACKAGES_REPOSITORY\n"
			if [ -n "$PACKAGE" -a -z "$REPACK" ]; then
				yesorno "Repack packages from rootfs (y/N) ? "
				REPACK="$answer"
				[ "$answer" = "y" ] || REPACK="n"
				[ "$DOWNLOAD" = "y" ] && break
			fi
			if [ -f $MIRROR -a -z "$DOWNLOAD" ]; then
				yesorno "Download packages from mirror (Y/n) ? "
				DOWNLOAD="$answer"
				if [ "$answer" = "n" ]; then
					[ -z "$PACKAGE" ] && exit 1
				else
					DOWNLOAD="y"
					[ -n "$REPACK" ] && break
				fi
			fi
			[ "$REPACK" = "n" -a "$DOWNLOAD" = "n" ] && exit 1
		done
		
		# Mount cdrom to be able to repack boot-loader packages
		if [ ! -e /boot -a -n "$CDROM" ]; then
			mkdir $TMP_MNT
			if mount -r $CDROM $TMP_MNT 2> /dev/null; then
				ln -s $TMP_MNT/boot /
				if [ ! -d "$ADDFILES/rootcd" ] ; then
					mkdir -p $ADDFILES/rootcd
					for i in $(ls $TMP_MNT); do
						[ "$i" = "boot" ] && continue
						cp -a $TMP_MNT/$i $ADDFILES/rootcd
					done
				fi
			else
				rmdir $TMP_MNT
			fi
		fi

		# Root fs stuff.
		echo "Preparing the rootfs directory..."
		mkdir -p $ROOTFS
		sleep 2
		for pkg in $LIST
		do
			[ "$pkg" = "" ] && continue
			# First copy and extract the package in tmp dir.
			pkg=${pkg%.tazpkg}
			PACKAGE=$(installed_package_name $pkg)
			mkdir -p $TMP_DIR
			if [ ! -f $PACKAGES_REPOSITORY/$pkg.tazpkg ]; then
				# Look for package in cache
				if [ -f $CACHE_DIR/$pkg.tazpkg ]; then
					ln -s $CACHE_DIR/$pkg.tazpkg $PACKAGES_REPOSITORY
				# Look for package in running distribution
				elif [ -n "$PACKAGE" -a "$REPACK" = "y" ]; then
					tazpkg repack $PACKAGE && \
					  mv $pkg.tazpkg $PACKAGES_REPOSITORY 
				fi
			fi
			if [ ! -f $PACKAGES_REPOSITORY/$pkg.tazpkg ]; then
				# Get package from mirror
				[ "$DOWNLOAD" = "y" ] && \
				download $pkg.tazpkg && \
				mv $pkg.tazpkg $PACKAGES_REPOSITORY
			fi
			if [ ! -f $PACKAGES_REPOSITORY/$pkg.tazpkg ]; then
				echo "Missing package $pkg."
				cleanup
				exit 1
			fi
		done
		if [ -f non-free.list ]; then
			echo "Preparing non-free packages..."
			cp non-free.list $ROOTFS/etc/tazlito/non-free.list
			for pkg in $(cat non-free.list); do
				if [ ! -d $INSTALLED/$pkg ]; then
					if [ ! -d $INSTALLED/get-$pkg ]; then
						tazpkg get-install get-$pkg
					fi
					get-$pkg
				fi
				tazpkg repack $pkg
				pkg=$(ls $pkg*.tazpkg)
				grep -q "^$pkg$" $LIST_NAME || \
					echo $pkg >>$LIST_NAME
				mv $pkg $PACKAGES_REPOSITORY 
			done
		fi
		echo ""
		cp $LIST_NAME $DISTRO/distro-packages.list
		sed 's/\(.*\)/\1.tazpkg/' < $DISTRO/distro-packages.list > $DISTRO/list-packages
		cd $PACKAGES_REPOSITORY
		yes y | tazpkg install-list \
			$DISTRO/list-packages --root=$ROOTFS
		cd $DISTRO
		cp distro-packages.list $ROOTFS/etc/tazlito
		# Copy all files from $ADDFILES/rootfs to the rootfs.
		if [ -d "$ADDFILES/rootfs" ] ; then
			echo -n "Copying addfiles content to the rootfs... "
			cp -a $ADDFILES/rootfs/* $ROOTFS
			status
		fi
		echo "Root file system is generated..."
		# Root CD part.
		echo -n "Preparing the rootcd directory..."
		mkdir -p $ROOTCD
		status
		# Move the boot dir with the Linux kernel from rootfs.
		# The boot dir goes directly on the CD.
		if [ -d "$ROOTFS/boot" ] ; then
			echo -n "Moving the boot directory..."
			mv $ROOTFS/boot $ROOTCD
			cd $ROOTCD/boot
			ln vmlinuz-* bzImage
			status
		fi
		cd $DISTRO
		# Copy all files from $ADDFILES/rootcd to the rootcd.
		if [ -d "$ADDFILES/rootcd" ] ; then
			echo -n "Copying addfiles content to the rootcd... "
			cp -a $ADDFILES/rootcd/* $ROOTCD
			status
		fi
		# Execute the distro script (used to perform tasks in the rootfs
		# before compression. Give rootfs path in arg
		[ -z $DISTRO_SCRIPT ] && DISTRO_SCRIPT=$TOP_DIR/distro.sh
		if [ -x $DISTRO_SCRIPT ]; then
			echo "Executing distro script..."
			sh $DISTRO_SCRIPT $DISTRO
		fi
		if [ -s /etc/tazlito/rootfs.list ]; then
			[ -f $ROOTCD/boot/isolinux/ifmem.c32 ] ||
			cp /boot/isolinux/ifmem.c32 $ROOTCD/boot/isolinux
			n=0
			last=$ROOTFS
			while read flavor; do
				n=$(($n+1))
				echo "Building $flavor rootfs..."
				download $flavor.flavor
				zcat $flavor.flavor | cpio -i $flavor.pkglist
				sed 's/.*/&.tazpkg/' < $flavor.pkglist \
					> $DISTRO/list-packages0$n
				mkdir ${ROOTFS}0$n
				cd $PACKAGES_REPOSITORY
				yes y | tazpkg install-list \
					$DISTRO/list-packages0$n --root=${ROOTFS}0$n
				rm -rf ${ROOTFS}0$n/boot
				status
				cd $DISTRO
				mv $flavor.pkglist ${ROOTFS}0$n/etc/tazlito/distro-packages.list
				rm -f $flavor.flavor install-list
				mergefs ${ROOTFS}0$n $last
				last=${ROOTFS}0$n
			done <<EOT
$(awk '{ for (i = 4; i <= NF; i+=2) print $i; }' < /etc/tazlito/rootfs.list)
EOT
			i=$(($n+1))
			while [ $n -gt 0 ]; do
				mv ${ROOTFS}0$n ${ROOTFS}$i
				echo "Compression ${ROOTFS}0$n ($(du -hs ${ROOTFS}$i | awk '{ print $1 }')) ..."
				gen_initramfs ${ROOTFS}$i
				n=$(($n-1))
				i=$(($i-1))
			done
			mv $ROOTFS ${ROOTFS}$i
			gen_initramfs ${ROOTFS}$i
			update_bootconfig $ROOTCD/boot/isolinux \
				"$(cat /etc/tazlito/rootfs.list)"
		else
			# Initramfs and ISO image stuff.
			gen_initramfs $ROOTFS
		fi
		gen_livecd_isolinux
		distro_stats
		cleanup
		;;
	clean-distro)
		# Remove old distro tree.
		#
		check_root
		echo ""
		echo -e "\033[1mCleaning :\033[0m $DISTRO"
		echo "================================================================================"
		if [ -d "$DISTRO" ] ; then
			if [ -d "$ROOTFS" ] ; then
				echo -n "Removing the rootfs..."
				rm -f $DISTRO/$INITRAMFS
				rm -rf $ROOTFS
				status
			fi
			if [ -d "$ROOTCD" ] ; then
				echo -n "Removing the rootcd..."
				rm -rf $ROOTCD
				status
			fi
			echo -n "Removing eventual ISO image..."
			rm -f $DISTRO/$ISO_NAME.iso
			rm -f $DISTRO/$ISO_NAME.md5
			status
		fi
		echo "================================================================================"
		echo ""
		;;
	check-distro)
		# Check for a few LiveCD needed files not installed by packages.
		#
		check_rootfs
		echo ""
		echo -e "\033[1mChecking distro :\033[0m $ROOTFS"
		echo "================================================================================"
		# SliTaz release info.
		if [ ! -f "$ROOTFS/etc/slitaz-release" ]; then
			echo "Missing release info : /etc/slitaz-release"
		else
			release=`cat $ROOTFS/etc/slitaz-release`
			echo -n "Release      : $release"
			status
		fi
		# Tazpkg mirror.
		if [ ! -f "$ROOTFS/var/lib/tazpkg/mirror" ]; then
			echo -n "Mirror URL   : Missing /var/lib/tazpkg/mirror"
			todomsg
		else
			echo -n "Mirror configuration exists..."
			status
		fi
		# Isolinux msg	
		if grep -q "cooking-XXXXXXXX" /$ROOTCD/boot/isolinux/isolinux.msg; then
			echo -n "Isolinux msg : Missing cooking date XXXXXXXX (ex `date +%Y%m%d`)"
			todomsg
		else
			echo -n "Isolinux message seems good..."
			status
		fi
		echo "================================================================================"
		echo ""
		;;
	writeiso)
				# Writefs to ISO image including /home unlike gen-distro we dont use
		# packages to generate a rootfs, we build a compressed rootfs with all 
		# the current filesystem similar to 'tazusb writefs'.
		#
		DISTRO="/home/slitaz/distro"
		ROOTCD="$DISTRO/rootcd"
		if [ -z $2 ]; then
			COMPRESSION=none
		else
			COMPRESSION=$2
		fi
		if [ -z $3 ]; then
			ISO_NAME="slitaz"
		else
			ISO_NAME="$3"
		fi
		check_root
		# Start info
		echo ""
		echo -e "\033[1mWrite filesystem to ISO\033[0m
===============================================================================
The command writeiso will write the current filesystem into a suitable cpio 
archive (rootfs.gz) and generate a bootable ISO image (slitaz.iso). 

Archive compression: $COMPRESSION"
		echo ""
		
		# Save some space
		rm /var/cache/tazpkg/* -r -f
		rm -rf /home/slitaz/distro

		# Optionally remove sound card selection and screen resolution.
		echo "Do you wish to remove the sound card and screen config ? "
		echo -n "Press ENTER to keep or anser (No|yes|exit): "
		read anser
		case $anser in
			e|E|"exit"|Exit)
				exit 0 ;;
			y|Y|yes|Yes)
				echo -n "Removing current sound card and screen configuration..."
				rm -f /var/lib/sound-card-driver
				rm -f /etc/asound.state
				rm -f /etc/X11/screen.conf 
				rm -f /etc/X11/xorg.conf ;;
			*)
				echo -n "Keeping current sound card and screen configuration..." ;;
		esac
		status
		
		# Create list of files including default user files since it is defined in /etc/passwd
		# and some new users might have been added.
		find /bin /etc /init /sbin /var /dev /lib /root /usr /home >/tmp/list

		for dir in /proc /sys /tmp /mnt /media /media/cdrom /media/flash /media/usbdisk
		do
			echo $dir >>/tmp/list
		done

		# Generate initramfs with specified compression and display rootf
		# size in realtime.
		rm -f /tmp/rootfs
		write_initramfs &
		sleep 2
		echo -en "\nFilesystem size:"
		while [ ! -f /tmp/rootfs ]
		do
			sleep 1
			echo -en "\\033[18G`du -sh /rootfs.gz | awk '{print $1}'`    "
		done
		echo -e "\n"

		# Move freshly generated rootfs to the cdrom.
		mkdir -p $ROOTCD/boot
		mv -f /rootfs.gz $ROOTCD/boot
		
		# Now we need the kernel and isolinux files.
		if mount /dev/cdrom /media/cdrom 2>/dev/null; then
			cp /media/cdrom/boot/bzImage $ROOTCD/boot
			cp -a /media/cdrom/boot/isolinux $ROOTCD/boot
			umount /media/cdrom
		else
			echo -e "
Unable to mount the cdrom to copy the Kernel and needed files. When SliTaz
is running in RAM the kernel and bootloader files are keeped on the cdrom.
Please insert a LiveCD or unmount curent cdrom to let Tazlito handle the media.\n"
			echo -en "----\nENTER to continue..."; read i
			exit 1
		fi
		
		# Generate the iso image.
		cd $DISTRO
		echo "Generating ISO image..."
		genisoimage -R -o $ISO_NAME.iso -b boot/isolinux/isolinux.bin \
		-c boot/isolinux/boot.cat -no-emul-boot -boot-load-size 4 \
		-V "SliTaz" -input-charset iso8859-1 -boot-info-table $ROOTCD
		if [ -x /usr/bin/isohybrid ]; then
			echo -n "Creating hybrid ISO..."
			/usr/bin/isohybrid $ISO_NAME.iso 2> /dev/null
			status
		fi
		echo -n "Creating the ISO md5sum..."
		md5sum $ISO_NAME.iso > $ISO_NAME.md5
		status

		echo "==============================================================================="
		echo "ISO image: `du -sh /home/slitaz/distro/$ISO_NAME.iso`"
		echo ""
		echo -n "Exit or burn ISO to cdrom (Exit|burn)? "; read anser
		case $anser in
			burn)
				eject
				echo -n "Please insert a blank cdrom and press ENTER..."
				read i && sleep 2
				tazlito burn-iso /home/slitaz/distro/$ISO_NAME.iso
				echo -en "----\nENTER to continue..."; read i ;;
			*)
				exit 0 ;;
		esac ;;
	burn-iso)
		# Guess cdrom device, ask user and burn the ISO.
		#
		check_root
		DRIVE_NAME=`cat /proc/sys/dev/cdrom/info | grep "drive name" | cut -f 3`
		DRIVE_SPEED=`cat /proc/sys/dev/cdrom/info | grep "drive speed" | cut -f 3`
		# We can specify an alternative ISO from the cmdline.
		if [ -n "$2" ] ; then
			iso=$2
		else
			iso=$DISTRO/$ISO_NAME.iso
		fi
		if [ ! -f "$iso" ]; then
			echo -e "\nUnable to find ISO : $iso\n"
			exit 0
		fi
		echo ""
		echo -e "\033[1mTazlito burn ISO\033[0m "
		echo "================================================================================"
		echo "Cdrom device  : /dev/$DRIVE_NAME"
		echo "Drive speed   : $DRIVE_SPEED"
		echo "ISO image     : $iso"
		echo "================================================================================"
		echo ""
		yesorno "Burn ISO image (y/N) ? "
		if [ "$answer" == "y" ]; then
			echo ""
			echo "Starting Wodim to burn the iso..." && sleep 2
			echo "================================================================================"
			wodim speed=$DRIVE_SPEED dev=/dev/$DRIVE_NAME $iso
			echo "================================================================================"
			echo "ISO image is burned to cdrom."
		else
			echo -e "\nExiting. No ISO burned."
		fi
		echo ""
		;;
	merge)
		# Merge multiple rootfs into one iso.
		#
		if [ -z "$2" ]; then
			cat << EOT
Usage: tazlito merge size1 iso size2 rootfs2 [sizeN rootfsN]...

Merge multiple rootfs into one iso. Rootfs are like russian dolls
i.e: rootfsN is a subset of rootfsN-1
rootfs1 is found in iso, sizeN is the RAM size need to launch rootfsN.
The boot loader will select the rootfs according to the RAM size detected.

Example: 
$ tazlito merge 160M slitaz-core.iso 96M rootfs-justx.gz 32M rootfs-base.gz

Will start slitaz-core with 160M+ RAM, slitaz-justX with 96M-160M RAM,
slitaz-base with 32M-96M RAM and display an error message if RAM < 32M.
EOT
			exit 2
		fi

		shift	# skip merge
		append="$1 slitaz1"
		shift	# skip size1
		mkdir -p $TMP_DIR/mnt $TMP_DIR/rootfs1

		ISO=$1.merged
		# Extract filesystems
		echo -n "Mounting $1"
		mount -o loop,ro $1 $TMP_DIR/mnt 2> /dev/null
		status || cleanup_merge
		cp -a $TMP_DIR/mnt $TMP_DIR/iso
		rm -f $TMP_DIR/iso/boot/bzImage
		ln $TMP_DIR/iso/boot/vmlinuz* $TMP_DIR/iso/boot/bzImage
		umount -d $TMP_DIR/mnt
		if [ -f $TMP_DIR/iso/boot/rootfs1.gz ]; then
			echo "$1 is already a merged iso. Aborting."
			cleanup_merge
		fi
		if [ ! -f $TMP_DIR/iso/boot/isolinux/ifmem.c32 ]; then
			if [ ! -f /boot/isolinux/ifmem.c32 ]; then
				cat <<EOT
No file /boot/isolinux/ifmem.c32
Please install syslinux package !
EOT
				rm -rf $TMP_DIR
				exit 1
			fi
			cp /boot/isolinux/ifmem.c32 $TMP_DIR/iso/boot/isolinux
		fi
		
		echo -n "Extracting iso/rootfs.gz"
		extract_rootfs $TMP_DIR/iso/boot/rootfs.gz $TMP_DIR/rootfs1 &&
		[ -d $TMP_DIR/rootfs1/etc ]
		status || cleanup_merge
		n=1
		while [ -n "$2" ]; do
			shift	# skip rootfs N-1
			p=$n
			n=$(($n + 1))
			append="$append $1 slitaz$n"
			shift	# skip size N
			mkdir -p $TMP_DIR/rootfs$n
			echo -n "Extracting $1"
			extract_rootfs $1 $TMP_DIR/rootfs$n &&
			[ -d $TMP_DIR/rootfs$n/etc ]
			status || cleanup_merge
			mergefs $TMP_DIR/rootfs$n $TMP_DIR/rootfs$p
			echo "Creating rootfs$p.gz"
			pack_rootfs $TMP_DIR/rootfs$p $TMP_DIR/iso/boot/rootfs$p.gz
			status
		done
		echo "Creating rootfs$n.gz"
		pack_rootfs $TMP_DIR/rootfs$n $TMP_DIR/iso/boot/rootfs$n.gz
		status
		rm -f $TMP_DIR/iso/boot/rootfs.gz
		update_bootconfig $TMP_DIR/iso/boot/isolinux "$append"
		echo "Generating $ISO"
		create_iso $ISO $TMP_DIR/iso
		rm -rf $TMP_DIR
		;;

	repack)
		# Repack an iso with maximum lzma compression ratio.
		#

		ISO=$2

		mkdir -p $TMP_DIR/mnt
		# Extract filesystems
		echo -n "Mounting $ISO"
		mount -o loop,ro $ISO $TMP_DIR/mnt 2> /dev/null
		status || cleanup_merge
		cp -a $TMP_DIR/mnt $TMP_DIR/iso
		umount -d $TMP_DIR/mnt
		
		for i in $TMP_DIR/iso/boot/rootfs* ; do
			echo -n "Repacking $(basename $i)"
			(zcat $i || unlzma -c $i || cat $i) \
				2>/dev/null > $TMP_DIR/rootfs
			lzma e $TMP_DIR/rootfs $i \
				 $(lzma_switches $TMP_DIR/rootfs)
			status
		done
		
		echo "Generating $ISO"
		create_iso $ISO $TMP_DIR/iso
		rm -rf $TMP_DIR ;;
	
	frugal-install|-fi)
		ISO_IMAGE="$2"
		echo ""
		mkdir -p /boot/frugal
		if [ -f "$ISO_IMAGE" ]; then
			echo -n "Using ISO image: $ISO_IMAGE"
			mkdir -p /tmp/iso && mount -o loop $ISO_IMAGE /tmp/iso
			status
			echo -n "Installing the Kernel and rootfs..."
			cp -a /tmp/iso/boot/bzImage /boot/frugal
			cp -a /tmp/iso/boot/rootfs.gz /boot/frugal
			umount /tmp/iso
			status
		else
			echo -n "Using distro: $DISTRO"
			cd $DISTRO && status
			echo -n "Installing the Kernel and rootfs..."
			cp -a $DISTRO/rootcd/boot/bzImage /boot/frugal
			cp -a $DISTRO/rootcd/boot/rootfs.gz /boot/frugal
			status
		fi
		# Grub entry
		if ! grep -q "^kernel /boot/frugal/bzImage" /boot/grub/menu.lst; then
			echo -n "Configuring GRUB menu list..."
			cat >> /boot/grub/menu.lst << EOT
title SliTaz GNU/Linux (frugal)
root (hd0,0)
kernel /boot/frugal/bzImage root=/dev/null
initrd /boot/frugal/rootfs.gz
EOT
		else
			echo -n "GRUB menu list is up-to-date..."
		fi
		status
		echo "" ;;
	
	emu-iso)
		# Emulate an ISO image with Qemu.
		if [ -n "$2" ] ; then
			iso=$2
		else
			iso=$DISTRO/$ISO_NAME.iso
		fi
		if [ ! -f "$iso" ]; then
			echo -e "\nUnable to find ISO : $iso\n"
			exit 0
		fi
		if [ ! -x "/usr/bin/qemu" ]; then
			echo -e "\nUnable to find Qemu binary. Please install: qemu\n"
			exit 0
		fi
		echo -e "\nStarting Qemu emulator:\n"
		echo -e "qemu $QEMU_OPTS $iso\n"
		qemu $QEMU_OPTS $iso ;;

	usage|*)
		# Clear and print usage also for all unknown commands.
		#
		clear
		usage ;;
esac

exit 0
